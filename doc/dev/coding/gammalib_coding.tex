%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GammaLib Coding conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions for manual package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\task}{\mbox{GammaLib}}
\newcommand{\this}{\mbox{\tt \task}}
\newcommand{\shorttype}{\mbox{CCD}}
\newcommand{\doctype}{\mbox{Coding Conventions Document}}
\newcommand{\version}{\mbox{draft}}
\newcommand{\calendar}{\mbox{23 January 2011}}
\newcommand{\auth}{\mbox{J\"urgen Kn\"odlseder}}
\newcommand{\approv}{\mbox{J\"urgen Kn\"odlseder}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}[12pt,a4]
\usepackage{epsfig}
\usepackage{manual}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin of document body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frontpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The present document summarises the coding conventions that should be
followed in implementing the \this\ toolbox.
The respect of coherent coding conventions throughout the code
improves code readibility and enhances the portability of the code.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% General coding rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General coding rules}

The following general rules should be followed:
\begin{itemize}
\item[R1] Each function and/or method terminates with a {\tt return;} statement.
\item[R2] Put a blank line at the end of each file.
\item[R3] Use {\tt explicit} for constructors to avoid use of the constructor for unintended
type conversion.
\item[R4] Do not use tabs (to make code formating independent of editor configurations)
type conversion.
\item[R5] Blocks are indented by 4 characters.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coding style
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coding style}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code configuration}

The code configuration is controlled via an include file that has to be added on top of
each source file.
Each source file should start with:

\begin{verbatim}
/* __ Includes ___________________________________________________________ */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
\end{verbatim}

Note that the {\tt config.h} file should {\bf not be included in header files}, since header file
are used by the outside world for which a different {\tt config.h} include file may exist.

One of the most common options used throughout \this\ is range checking.
Range checking is particularily important during code development since it allows to catch
memory leaks.
However, range checking is time consuming and thus leads to somewhat slower code.
Range checking can thus be disable during installation of \this\ by using
{\tt ./configure --disable-range-check} during library installation.
Within the code, the following instruction adds range checking that dependens on
the library configuration:

\begin{verbatim}
#if defined(G_RANGE_CHECK)
if (inx < 0 || inx >= m_num)
    throw GException::out_of_range("GVector::operator(int)", inx, m_num);
#endif
\end{verbatim}

Range checking is provided if the {\tt G\_RANGE\_CHECK} macro is defined.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Header inclusions}

Each file should contain the {\tt \#include} directives that are necessary for compilation of
the specific file.
Only {\tt \#include} directives that are already given by the corresponding header file can
be omitted.

Note also that some compilers are more tolerant in omitting {\tt \#include} directives, such
as {\tt <stdio.h>} or {\tt <string.h>}, so these directives should also be included for compatibility,
even if they seem not to be required on specific systems.
Examples of include directives needed by common functions are:
\begin{itemize}
\item[] {\tt <stdio.h>} contains {\tt fopen}, {\tt fgets}, {\tt fclose}, {\tt fprintf}, {\tt sprintf}
\item[] {\tt <string.h>} contains {\tt strncpy}, {\tt memcpy}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Data}

Class data should be either {\tt private} or {\tt protected}, the latter being generally used
when a derived class should be able to access base class data.

Data members should be prefixed by {\tt m\_} and should be in lower case.
For long member names, additional underscores may be added.
Examples of valid member names are
\begin{verbatim}
  m_num
  m_response
  m_grid_length
  m_axis_dir_qual
\end{verbatim}

Initialisation, copying and deleting of class members should be gathered in a single
place to avoid memory leaks.
For this purpose, each C++ class should have the following {\tt private} or {\tt protected}
methods for memory management:
\begin{itemize}
\item {\tt init\_members()} initializes all member variables and pointers to well defined
initial values. The class should be fully operational and consistent with these initial
values. All pointers that will hold dynamically allocated memory should be
initialised to {\tt NULL}.
\item {\tt copy\_members(const \&A a)} copies all members from one instance {\tt a}
to the {\tt this} instance.
\item {\tt free\_members()} frees all memory that has been allocated by the class.
Memory pointers should be set to {\tt NULL} after the memory was deleted to signal
that no valid memory is associated to the pointer.
This allows for checking if memory has been allocated before it is accessed.
\end{itemize}
(in the above notation, {\tt A} is the class name and {\tt a} is an instance of the class).

An example for valid {\tt init\_members()}, {\tt copy\_members(const \&A a)} and
{\tt free\_members()} methods is:
\begin{verbatim}
void GEbounds::init_members(void)
{
    m_num = 0;
    m_min = NULL;
    m_max = NULL;
    return;
}

void GEbounds::copy_members(const GEbounds& ebds)
{
    m_num  = ebds.m_num;
    if (m_num > 0) {
        m_min = new GEnergy[m_num];
        m_max = new GEnergy[m_num];
        for (int i = 0; i < m_num; ++i) {
            m_min[i] = ebds.m_min[i];
            m_max[i] = ebds.m_max[i];
        }
    }
    return;
}

void GEbounds::free_members(void)
{
    if (m_min != NULL) delete [] m_min;
    if (m_max != NULL) delete [] m_max;
    m_min = NULL;
    m_max = NULL;
    return;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Constructors, destructors and operators}

Each class should have at least a void constructor, a copy constructor, a destructor and
an assignment operator.
Additional constructors and operators can be implemented as required.
The following example shows the basic implementation for these 4 methods.
Due to the usage of the {\tt init\_members()}, {\tt copy\_members(const \&A a)} and the
{\tt free\_members()} methods, most classes will have exactly this kind of syntax:
\begin{verbatim}
GEbounds::GEbounds(void)
{
    init_members();
    return;
}

GEbounds::GEbounds(const GEbounds& ebds)
{
    init_members();
    copy_members(ebds);
    return;
}

GEbounds::~GEbounds(void)
{
    free_members();
    return;
}

GEbounds& GEbounds::operator= (const GEbounds& ebds)
{
    if (this != &ebds) {
        free_members();
        init_members();
        copy_members(ebds);
    }
    return *this;
}
\end{verbatim}
Note that for a derived class, the assignment operator will have the form:
\begin{verbatim}
GEventCube& GEventCube::operator= (const GEventCube& cube)
{
    if (this != &cube) {
        this->GEvents::operator=(cube);    // Copy base class members
        free_members();
        init_members();
        copy_members(cube);
    }
    return *this;
}
\end{verbatim}
Also note that {\bf for a derived class, {\tt init\_members()}, {\tt copy\_members(const \&A a)}
and {\tt free\_members()} should only act on derived class members but not on
base class members}.
Any exception from this rule needs very careful documentation since it can easily be
the source of memory leaks.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Methods}

Uniform {\tt public} method names should be provided throughout \this\ for all classes.
Unless the {\tt public} method names are very long (which should be avoided), names
should not comprise underscores as separators.
{\tt Public} method names are all lowercase.

{\tt Private} or {\tt protected} may differ from this since they are hidden within the class.
Yet also here, all method names should be lowercase, and the use of underscores
should be limited.
 
In addition, the following {\tt public} method names should be used:

%%% Naming conventions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!h]
\caption{Naming conventions for class methods.
\label{tab:naming}}
\begin{center}
\begin{tabular}{lll}
\hline
\hline
\noalign{\smallskip}
Method & Usage & Implementation \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt clear()} & Set object to initial empty state & All classes \\
{\tt print()} & Print object into string & All classes (see section \ref{sec:output}) \\
{\tt append()} & Append element to list of elements & Class containing elements \\
{\tt size()} & Return number of elements in object & Class containing elements \\
{\tt load()} & Load data from file (open, read, close) & When useful \\
{\tt save()} & Save data into file (open, write, close) & When useful \\
{\tt read()} & Read data from open file & When useful \\
{\tt write()} & Write data into open file & When useful \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note the difference between {\tt load()} and {\tt read()} and between {\tt save()} and {\tt write()}.
The {\tt load()} and {\tt save()} methods should take as arguments a file name, and they
will open the file, read or write some data, and then close the file.
In contrast, {\tt read()} and {\tt write()} will operate on files that are already open, and after
the read or write operation the files will remain open.
Typically, these methods take a {\tt GFits*} or a {\tt GFitsHDU*} pointer as argument.

Methods that perform checks should return a {\tt bool} type and should start with the
prefix {\tt is} or {\tt has}.

Valid examples are:
\begin{verbatim}
  islong()
  isin()
  hasedisp()
\end{verbatim}

Method arguments should be generally passed as {\tt const} and by reference.

Numeric argument types should be typically {\tt int} and {\tt double}.
Unless absolutely required, {\tt short int}, {\tt long}, and {\tt float} should be avoided.
True/false checks should always be done using {\tt bool}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Output}
\label{sec:output}

Output stream and logging operators should be implemented for every class as friend
operators.
An example is:
\begin{verbatim}
#include <iostream>
#include "GLog.hpp"
class GFits {
    friend std::ostream& operator<< (std::ostream& os, const GFits& fits);
    friend GLog&         operator<< (GLog& log, const GFits& fits);
    ...
\end{verbatim}
The usage of friend operators (instead of member operators) allows for correct handling
of code such as
\begin{verbatim}
log << std::endl << "This is a text" << std::endl;
\end{verbatim}
To support these friend operators (and to support also the Python interface), each class
should have a {\tt print()} method:
\begin{verbatim}
std::string print(void) const;
\end{verbatim}
Using the {\tt print()} method the output operators will take the following generic form:
\begin{verbatim}
std::ostream& operator<< (std::ostream& os, const GFits& fits)
{
    os << fits.print();
    return os;
}
GLog& operator<< (GLog& log, const GFits& fits)
{
    log << fits.print();
    return log;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Documentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Documentation}

Code documentation should be done within the source files using Doxygen
compliant annotations.

The following rules apply.


\subsection{File descriptor}

Put a 80 character wide header comment on top of {\bf each file}
(header, source code, templates, etc.).
The header contains
the file name,
a brief description of the file content,
the development period and the name of the person which {\bf initially}
created the file, and
a standard GNU Public License statement.
The header comment is immediately followed by a Doxygen compliant
file description that provides
the file name,
a brief description of the file content, and
the name of the person which {\bf initially} created the file.
\begin{verbatim}
/***************************************************************************
 *                       GMatrix.cpp  -  matrix class                      *
 * ----------------------------------------------------------------------- *
 *  copyright (C) 2006-2010 by Jurgen Knodlseder                           *
 * ----------------------------------------------------------------------- *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
/**
 * @file GMatrix.cpp
 * @brief GVector class implementation.
 * @author J. Knodlseder
 */
\end{verbatim}

\end{document}

