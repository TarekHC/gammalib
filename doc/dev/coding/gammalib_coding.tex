%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GammaLib Coding and Design Conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions for manual package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\task}{\mbox{GammaLib}}
\newcommand{\this}{\mbox{\tt \task}}
\newcommand{\shorttype}{\mbox{CDC}}
\newcommand{\doctype}{\mbox{Coding and Design Conventions}}
\newcommand{\version}{\mbox{draft}}
\newcommand{\calendar}{\mbox{15 December 2012}}
\newcommand{\auth}{\mbox{J\"urgen Kn\"odlseder}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}[12pt,a4]
\usepackage{epsfig}
\usepackage{manual}
\usepackage{url}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin of document body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frontpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

This document summarises the coding and design conventions that should be following for
the \this\ development.

Respecting uniform and coherent coding and design conventions is crucial for software
development.
They improve code readability, ease code development and maintenance, ensure code
portability, and provide standards for the user interface.

Coding and design conventions were introduced at a very early stage of the \this\ project, and
are followed as strictly as possible.
The choices that were made for \this\ were inspired by a large survey of existing C++ coding
rules, combined with the experience of the leading code developers.
Obviously, there is no single best way to code in C++, and the adopted conventions may not
meet the coding usage of individual developers.
They should nevertheless be respected strictly, as the \this\ code base is already very large,
and assuring uniformity and coherence is a primary goal of the project.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% General coding rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General coding rules}

This section provides lists of general coding rules for the \this\ development.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ rules}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Code format}

\begin{itemize}
\item Blocks are indented by 4 characters.
\item Do not use tabs (code formatting should be independent of editor configurations).
\item Do not exceed a line length of 80 characters (a few more characters are in exceptional cases acceptable).
\item Put a blank line at the end of each file (this is required by some compilers).
\item Each function starts with a curly bracket in the line following the function name.
The return type is in the same line as the function name. Example:
\begin{verbatim}
void function(void)
{
    int = 0;
    return;
}
\end{verbatim}
\item Each block should be encompassed in curly brackets, even if the block consists only
of a single line.
\item The opening curly bracket of a block starts in the same line as the related statement. 
Example:
\begin{verbatim}
for (int i = 0; i < 10; ++i) {
    sum += i;
}
\end{verbatim}
\item Use spaces between code elements (see above example).
\item Align successive similar lines on common elements.
Example illustrating the alignment on the {\tt =} symbol:
\begin{verbatim}
m_max    = par.m_max;
m_prompt = par.m_prompt;
sum     += par.m_sum;
\end{verbatim}
Example illustrating the alignment in a class definition on the member function name:
\begin{verbatim}
void        log10GeV(const double& eng);
void        log10TeV(const double& eng);
std::string print(void) const;
\end{verbatim}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Code semantics}

\begin{itemize}
\item Each function and/or method terminates with a {\tt return} statement.
\item Each function and/or method has only a single exit point (i.e. a single {\tt return} statement).
\item Use {\tt explicit} for constructors with arguments to prevent unintended type conversions.
The only exception to this rule is the copy constructor or type conversion constructors.
\item Specify {\tt void} for function definitions without arguments.
\item Use pre incrementation in loops (pre incrementation is faster than post incrementation).
Example:
\begin{verbatim}
for (int i = 0; i < 10; ++i) {
    sum += i;
}
\end{verbatim}
\item Where possible (and appropriate), use {\tt std::vector} containers instead of
allocating memory. In other words: avoid direct memory allocation.
\item Provide comments, comments, comments!!!
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Language features}

\begin{itemize}
\item Do not use templates.
\item Do not use macros.
\item Do not use namespaces.
\item Do not use {\tt \#define} directives for the declaration of constants. Use {\tt const} instead.
\item Do not use {\tt std::strncpy}, {\tt std::memcpy} or similar as these functions are corrupted on
some systems.
\item If possible, pass arguments by reference.
\item Use C++ (std::string) instead of C-style (char*) strings.
\item Use C++ casts instead of C-style casts.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python rules}

\begin{itemize}
\item All code must be compatible with Python 2.4, 2.5, 2.6, 2.7 as well as 3.2 or later.
\item In the future we might drop support for Python 2.4 and 2.5. Python 2.6 was released in 2008 and
is much more modern and Python 3 compatible that Python 2.4 and 2.5.\\
\url{http://docs.python.org/2/whatsnew/2.6.html}
\item Python code should follow the official PEP8 Python style:\\
\url{http://www.python.org/dev/peps/pep-0008/}\\
It says (among many other things) that you should indent with four spaces, not tabs.
Following PEP8 is simple, because there's a {\tt pep8} tool (\url{https://github.com/jcrocholl/pep8}) that you should
run on your Python code before committing, e.g. like so:
\begin{verbatim}
$ pep8 test/test_python.py
...
test/test_python.py:156:1: W191 indentation contains tabs
test/test_python.py:156:1: W391 blank line at end of file
test/test_python.py:156:1: W293 blank line contains whitespace
$
\end{verbatim}
If you want you can even use the {\tt autopep8} tool (\url{https://github.com/hhatto/autopep8}) which can
automatically fix the formatting for almost all cases. Run {\tt pep8 -h} and {\tt autopep8 -h} to see
the options you can use.
PEP8 compliance is automatically checked by the continuous integration system.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coding conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coding conventions}

The style summarizes coding conventions for the \this\ development.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{General rules}

Each class should be defined in a pair of individual files:
\begin{itemize}
\item a header file that defines the class interface (with filename suffix {\tt .hpp})
\item a source code file that implements the class (with filename suffix {\tt .cpp})
\end{itemize}
In addition, a SWIG interface file should be provided for the Python bindings (with filename suffix {\tt .i}).

Each file should contain the {\tt \#include} directives that are necessary for compilation of
the specific file.
{\tt \#include} directives that are specified in the header file can be omitted in the source code
file, provided that the header file is include in the source code file.

The C++ style header files should be used instead of the C style header files to ensure 
maximum portability.
The following table provides the correspondence between C++ and C header files for
headers commonly used in \this.

%%% Header files correspondence %%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{lll}
\hline
\hline
\noalign{\smallskip}
C++ & C & Function examples \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt <cctype>} & & \\
{\tt <cmath>} & {\tt <math.h>} & {\tt std::abs}, {\tt std::cos} \\
{\tt <cfloat>} & & \\
{\tt <cstdio>} & {\tt <stdio.h>} & {\tt std::fopen}, {\tt std::fgets}, {\tt std::fclose}, {\tt std::fprintf}, {\tt std::sprintf} \\
{\tt <cstdlib>} & & \\
{\tt <cstring>} & {\tt <string.h>} & {\tt std::strlen} \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that functions and types should be prefixed by {\tt std::}.
For example,
{\tt cos} becomes {\tt std::cos},
{\tt time\_t} becomes {\tt std::time\_t}, etc.
One significant change between C and C++ is that {\tt fabs} becomes {\tt std::abs} since
the C style {\tt abs} function only applies to integers.
Here, the {\tt std::} prefix is crucial to distinguish the C++ function (which is
also defined for doubles) from the C function.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Header file structure}
\label{sec:header}

The header file defines the interface of the class.
Here is an example of a header file.
\begin{verbatim}
/***************************************************************************
 *                        GClass.hpp  -  My nice class                     *
 * ----------------------------------------------------------------------- *
 *  copyright (C) 2010-2012 by Juergen Knoedlseder                         *
 * ----------------------------------------------------------------------- *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                         *
 ***************************************************************************/
/**
 * @file GClass.hpp
 * @brief Definition of my nice class interface
 * @author Juergen Knoedlseder
 */

#ifndef GCLASS_HPP
#define GCLASS_HPP

/* __ Includes ___________________________________________________________ */
#include <string>
#include <iostream>
#include "GLog.hpp"


/***********************************************************************//**
 * @class GClass
 *
 * @brief Illustration of a GammaLib class
 *
 * My nice class illustrates how a GammaLib class should be defined.
 ***************************************************************************/
class GClass {

    // I/O friends
    friend std::ostream& operator<< (std::ostream& os, const GClass& c);
    friend GLog&         operator<< (GLog& log, const GClass& c);

public:
    // Constructors and destructors
    GClass(void);
    GClass(const GClass& c);
    virtual ~GClass(void);
 
    // Operators
    GClass& operator= (const GClass& c);

    // Methods
    void        clear(void);
    GClass*     clone(void) const;
    std::string print(void) const;
  
protected:
    // Protected methods
    void init_members(void);
    void copy_members(const GClass& c);
    void free_members(void);

    // Protected data members
    std::string     m_name;          //!< Name
};

#endif /* GCLASS_HPP */
\end{verbatim}

The header file starts with a comment containing the file name and class purpose, the
copyright information and the license text.
The years in the copyright information should cover the years over which the file has been
modified, the author is the person who initially created the file.

Following the header comment is a comment that provides file information to the
Doxygen documentation system.

The subsequent
\begin{verbatim}
    #ifndef GCLASS_HPP
    #define GCLASS_HPP
\end{verbatim}
declarations together with the 
\begin{verbatim}
    #endif /* GCLASS_HPP */
\end{verbatim}
declaration at the end protect the file from multiple inclusions of the header.
This is a crucial feature needed for proper compilation of the code.

Now all header files are included.
Standard header files are included using the {\tt < >} brackets, \this\ header files are included
using {\tt " "}.
A 80 character long separator precedes the header inclusion.
Further 80 character long separators may be added for additional sections, such as
constants, type definitions, forward declarations, etc.
Use one separator to precede each additional section.

The class definition is preceded by a comment block that will be used by the Doxygen system
to extract the class definition.
Provide here the class name, a brief one line description of the class, and an extended
detailed description of the class purpose.

The class definition is structured in several sections:
\begin{itemize}
\item Declaration of friend functions
\item Definition of public constructors
\item Definition of public operators
\item Definition of public methods
\item Definition of protected methods
\item Definition of protected members
\end{itemize}
The definition of pure virtual methods should be done in a section that is separate from the
methods that are implemented.
Output stream and logging operators should be implemented for every class as friend
operators.

Here any illustration of the expected structure, based on the {\tt GObservation} class:
\begin{verbatim}
class GObservation {

    // Friend classes
    friend std::ostream& operator<< (std::ostream& os, const GObservation& obs);
    friend GLog&         operator<< (GLog& log,        const GObservation& obs);

public:
    // Constructors and destructors
    GObservation(void);
    GObservation(const GObservation& obs);
    virtual ~GObservation(void);

    // Operators
    virtual GObservation& operator= (const GObservation& obs);

    // Pure virtual methods
    virtual void          clear(void) = 0;
    virtual GObservation* clone(void) const = 0;

    // Virtual methods
    virtual double        model(const GModels& models, const GEvent& event,
                                GVector* gradient = NULL) const;
    virtual double        npred(const GModels& models, GVector* gradient = NULL) const;

    // Implemented methods
    void                  name(const std::string& name);
    void                  id(const std::string& id);

protected:
    // Protected methods
    void init_members(void);
    void copy_members(const GObservation& obs);
    void free_members(void);

    // Protected data area
    std::string m_name;         //!< Name of observation
    std::string m_id;           //!< Observation identifier
    std::string m_statistics;   //!< Optimizer statistics (default=poisson)
    GEvents*    m_events;       //!< Pointer to event container
};
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Source code file structure}
\label{sec:sourcecode}

The source code file implements the code of the class.
Here is an example of the start of a source code file.
\begin{verbatim}
/***************************************************************************
 *                        GClass.cpp  -  My nice class                     *
 * ----------------------------------------------------------------------- *
 *  copyright (C) 2010-2012 by Juergen Knoedlseder                         *
 * ----------------------------------------------------------------------- *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                         *
 ***************************************************************************/
/**
 * @file GClass.cpp
 * @brief Implementation of my nice class
 * @author Juergen Knoedlseder
 */

/* __ Includes ___________________________________________________________ */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "GClass.hpp"
#include "GTools.hpp"

/* __ Method name definitions ____________________________________________ */
#define G_CLEAR                                             "GClass::clear()"
#define G_CLONE                                       "GClass::clone() const"
#define G_PRINT                                       "GClass::print() const"

/* __ Compile options ____________________________________________________ */
#define G_USE_MY_OPTION

/* __ Debug options ______________________________________________________ */
#define G_DEBUG_PRINT

/* __ Constants __________________________________________________________ */
const double pi = 3.14;
\end{verbatim}

The include section starts with a conditional include of the code configuration header file
(see section \ref{sec:configure}).
This makes \this\ compile options available to the source code.

The include section is followed by the declaration of method names.
These method names will be used in exceptions (see section \ref{sec:exceptions}).
Define the method names at the top of the file eases the maintainability of the code,
as changes in method names or interfaces need only to be implemented in a single 
place.
Method names need only be defined for methods throwing exceptions.

Compile options are used to control which parts of the code should be compiled.
Such options may be used, for example, to compare different algorithms or computation
methods.
They can also be used during development, allowing an easy switch between the new and
the old code for comparison.

Debug options are compile options that are used to add additional code for debugging.
Often, these are print statements that allow to trace the execution of the code.
For code checked into the repository, all debug options should be commented out.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python classes}
\label{sec:pyhton}

The Python interface for C++ classes is defined by a so-called SWIG interface file.
SWIG uses these interface files to build Python wrapper files, which are C files
that define the interface between \this\ and Python.
The structure of the SWIG interface file follows closely that of the header file, with
a few exceptions.
Here an example:
\begin{verbatim}
/***************************************************************************
 *                         GClass.i  -  My nice class                      *
 * ----------------------------------------------------------------------- *
 *  copyright (C) 2010-2012 by Juergen Knoedlseder                         *
 * ----------------------------------------------------------------------- *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                         *
 ***************************************************************************/
/**
 * @file GClass.i
 * @brief Python interface of my nice class
 * @author Juergen Knoedlseder
 */
%{
/* Put headers and other declarations here that are needed for compilation */
#include "GClass.hpp"
#include "GTools.hpp"
%}


/***********************************************************************//**
 * @class GClass
 *
 * @brief Illustration of a GammaLib class
 *
 * My nice class illustrates how a GammaLib class should be defined.
 ***************************************************************************/
class GClass {
public:
    // Constructors and destructors
    GClass(void);
    GClass(const GClass& c);
    virtual ~GClass(void);

    // Methods
    void        clear(void);
    GClass*     clone(void) const;
};


/***********************************************************************//**
 * @brief GClass class extension
 ***************************************************************************/
%extend GClass {
    char *__str__() {
        return tochar(self->print());
    }
    GClass copy() {
        return (*self);
    }
};
\end{verbatim}

The code starts with a section that is enclosed in {\tt \%\{  \%\}} brackets.
In this section, all header files are specified that are needed to compile the SWIG wrapper
file.

Then follows the class definition, with the following differences with respect to the
definition in the header file:
\begin{itemize}
\item it does not include the assignment operator
\item it does not include any access operator (these have to be implemented specifically, see below)
\item it does not include the {\tt print()} method (see below)
\item it does not include protected or private members
\end{itemize}

Finally, there is a section with extension to the C++ class.
Here, methods are implement that do not exist in the actual C++ class, but that will
exist in the Python interface.
In this example, the {\tt\_\_str\_\_()} method is the generic Python conversion operator that
converts an object into a string.
It can be seen that this method calls the class's @print()@ method.
By providing the conversion method, the class becomes "printable", and one
my specify
\begin{verbatim}
>>> GClass c
>>> print c
\end{verbatim}
to print out the class (i.e. to invoke the print() method of the class).

In case that an access operator needs to be implement, the {\tt\_\_getitem\_\_()} and {\tt\_\_setitem\_\_()}
methods need to be added to the class extensions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Design conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design conventions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code configuration}
\label{sec:configure}

The code configuration is controlled via the {\tt config.h} header file that is created during the
configuration step of \this.
To make configuration options available the following code has to be added to the
source code file:
\begin{verbatim}
/* __ Includes ___________________________________________________________ */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
\end{verbatim}
Note that the {\tt config.h} file should {\bf not be included in header files}, since header files
are used by the outside world without any knowledge about {\tt config.h}.

One of the most commonly used configuration options used throughout \this\ is related to
range checking.
Range checks are usually performed when accessing array elements, assuring that no
elements outside the valid range are accessed.
Range checking, however, is time consuming, in particular if many elements are
accessed subsequently.
\this\ therefore allows to disable range checks.
This can be done by specifying {\tt ./configure --disable-range-check} when configuring 
\this\ for compilation.
The {\tt --disable-range-check} option undefines {\tt G\_RANGE\_CHECK}, and optional
range checking is thus achieved by adding for example
\begin{verbatim}
#if defined(G_RANGE_CHECK)
if (inx < 0 || inx >= m_num) {
    throw GException::out_of_range("GVector::operator(int)", inx, m_num);
}
#endif
\end{verbatim}
to the code.

The following table gives a list of important configuration options that are available in 
{\tt config.h} and that can be used to tune the code:

%%% Configuration options %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{lll}
\hline
\hline
\noalign{\smallskip}
Definition & Option & Usage \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt G\_DEBUG} & {\tt --enable-debug} & Code debugging \\
{\tt G\_PROFILE} & {\tt --enable-profiling} & Code profiling \\
{\tt G\_RANGE\_CHECK} & {\tt --enable-range-check} & Performs range checking \\
{\tt G\_NAN\_CHECK} & {\tt --enable-nan-check} & Check for NaN and Inf values \\
{\tt G\_SMALL\_MEMORY} & {\tt --enable-small-memory} & Optimizes for small memory \\
{\tt HAVE\_OPENMP} &{\tt  --enable-openmp} & Has OpenMP multi-threading support \\
{\tt HAVE\_LIBREADLINE} & {\tt --with-readline} & Has readline library \\
{\tt HAVE\_LIBCFITSIO} & {\tt --with-cfitsio} & Has cfitsio library \\
{\tt HAVE\_PYTHON} & {\tt --enable-python-binding} & Has Python bindings \\
{\tt PACKAGE} & n.a. & {\tt gammalib} \\
{\tt PACKAGE\_PREFIX} & n.a. & Installation location (e.g. {\tt /usr/local/gamma}) \\
{\tt PACKAGE\_STRING} & n.a. & Full name and version of \this\ \\
{\tt PACKAGE\_VERSION} & n.a. & Version of \this\ (format: x.y.z) \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that {\tt enable} may be replaced by {\tt disable} and {\tt with} by {\tt without} for switching off
an option.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Members}

Class members should be either {\tt private} or {\tt protected}, the latter being generally used
when a derived class should be able to access base class data.

Members should be prefixed by {\tt m\_} and should be in lower case.
For long member names, additional underscores may be added.
Examples of valid member names are
\begin{verbatim}
m_num
m_response
m_grid_length
m_axis_dir_qual
\end{verbatim}

Initialisation, copying and deleting of class members should be gathered in a single
place to avoid memory leaks.
For this purpose, each C++ class should have the following {\tt private} or {\tt protected}
methods for memory management:
\begin{itemize}
\item {\tt init\_members()} initializes all member variables and pointers to well defined
initial values. The class should be fully operational and consistent with these initial
values. All pointers that will hold dynamically allocated memory should be
initialised to {\tt NULL}.
\item {\tt copy\_members(const \&A a)} copies all members from an instance {\tt a}
into the class.
\item {\tt free\_members()} frees all memory that has been allocated by the class.
Memory pointers should be set to {\tt NULL} after the memory was deleted to signal
that no valid memory is associated to the pointer.
This allows for checking if memory has been allocated before it is accessed.
\end{itemize}
(in the above notation, {\tt A} is the class name and {\tt a} is an instance of the class).

An example for valid {\tt init\_members()}, {\tt copy\_members(const \&A a)} and
{\tt free\_members()} methods is:
\begin{verbatim}
void GEbounds::init_members(void)
{
    m_num = 0;
    m_min = NULL;
    m_max = NULL;
    return;
}

void GEbounds::copy_members(const GEbounds& ebds)
{
    m_num  = ebds.m_num;
    if (m_num > 0) {
        m_min = new GEnergy[m_num];
        m_max = new GEnergy[m_num];
        for (int i = 0; i < m_num; ++i) {
            m_min[i] = ebds.m_min[i];
            m_max[i] = ebds.m_max[i];
        }
    }
    return;
}

void GEbounds::free_members(void)
{
    if (m_min != NULL) delete [] m_min;
    if (m_max != NULL) delete [] m_max;
    m_min = NULL;
    m_max = NULL;
    return;
}
\end{verbatim}
In this example, on may probably want to add a {\tt alloc\_members()} method for memory allocation:
\begin{verbatim}
void GEbounds::alloc_members(const int& num)
{
    if (num > 0) {
        m_min = new GEnergy[num];
        m_max = new GEnergy[num];
        for (int i = 0; i < num; ++i) {
            m_min[i] = 0.0;
            m_max[i] = 0.0;
        }
        m_num = num;
    }
    return;
}
\end{verbatim}
This example illustrates several design conventions:
\begin{itemize}
\item Always check if a pointer is not {\tt NULL} before de-allocating memory.
\item After de-allocation, always set the pointer immediately to {\tt NULL}.
\item Never allocate zero elements (check if the number of elements to be allocated is positive).
\item Always initialise allocated memory to well defined values (do not expect that the compiler
will do this for your).
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Constructors, destructors and operators}

Each class should have at least a void constructor, a copy constructor, a destructor and
an assignment operator.
Additional constructors and operators can be implemented as required.
The following example shows the basic implementation for these 4 methods.
Due to the usage of the {\tt init\_members()}, {\tt copy\_members(const \&A a)} and the
{\tt free\_members()} methods, most classes will have exactly this kind of syntax:
\begin{verbatim}
GEbounds::GEbounds(void)
{
    init_members();
    return;
}

GEbounds::GEbounds(const GEbounds& ebds)
{
    init_members();
    copy_members(ebds);
    return;
}

GEbounds::~GEbounds(void)
{
    free_members();
    return;
}

GEbounds& GEbounds::operator= (const GEbounds& ebds)
{
    if (this != &ebds) {
        free_members();
        init_members();
        copy_members(ebds);
    }
    return *this;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inheritance}

Class inheritance is central feature of the C++ language, and is largely used throughout \this.
Multiple inheritance is not used at the moment in \this.
Because of the added complexity of multiple inheritance in C++ in python there would have to 
be very good reasons to use it in \this.

Although the inheritance philosophy may differ from class to class, the following guidelines
should be respected as far as possible:
\begin{itemize}
\item The base class and derived class destructors should be declared {\tt virtual}.
\item Avoid overloading of base class methods by derived class methods. 
Preferentially, define base class methods as pure virtual.
\item All base class methods that should be implemented in the derived class should
be declared {\tt virtual}.
Exceptions are the {\tt init\_members()}, the {\tt copy\_members()} and the {\tt free\_members()}
methods that will be implemented in the base class and the derived class.
\item Base classes manage base class members, derived classes manage derived class
members. 
By managing we mean here in particular memory allocation and de-allocation,
but also proper initialization.
\item Derived class constructors should invoke base class constructors for proper
base class initialization. A void constructor should look like
\begin{verbatim}
GEventList::GEventList(void) : GEvents()
{
    init_members();
    return;
}
\end{verbatim}
and a copy constructor should look like
\begin{verbatim}
GEventList::GEventList(const GEventList& list) : GEvents(list)
{
    init_members();
    copy_members(list);
    return;
}
\end{verbatim}
\item Derived class operators should invoke base class operators, as illustrated
by the following example:
\begin{verbatim}
GEventList& GEventList::operator=(const GEventList& list)
{
    if (this != &list) {
        this->GEvents::operator=(list);
        free_members();
        init_members();
        copy_members(list);
    }
    return *this;
}
\end{verbatim}
\item The {\tt clear()} method of a derived class show invoke the {\tt free\_members()} method
of the base class, as illustrated by the following example:
\begin{verbatim}
void GCTAEventList::clear(void)
{
    free_members();
    this->GEventList::free_members();
    this->GEvents::free_members();
    this->GEvents::init_members();
    this->GEventList::init_members();
    init_members();
    return;
}
\end{verbatim}
\item Avoid as far as possible methods that are only defined in the derived class.
\end{itemize}

Also note that {\bf for a derived class, {\tt init\_members()}, {\tt copy\_members(const \&A a)}
and {\tt free\_members()} should only act on derived class members but not on
base class members}.
Any exception from this rule needs very careful documentation since it can easily be
the source of memory leaks.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Method naming conventions}

Uniform {\tt public} method names should be provided throughout \this\ for all classes.
Unless the {\tt public} method names are very long (which should be avoided), names
should not comprise underscores as separators.
{\tt Public} method names are all lowercase.

{\tt Private} or {\tt protected} method name may differ from this since they are hidden within 
the class.
Yet also here, all method names should be lowercase, and the use of underscores
should be limited.

Methods that set or retrieve class attributes should be named after the attribute.
Here an example for the attribute {\tt m\_name}:
\begin{verbatim}
public:
    void        name(const std::string& name);
    std::string name(void) const;
protected:
    m_name;
\end{verbatim}

A method name that is used in multiple classes should always perform an equivalent action.
Here is a list of method names that are widely used in \this, together with their typical usage.
The last column specifies where these methods are used.
Note that {\bf the {\tt clear()}, {\tt clone()}, and {\tt print()} methods should be implemented for all 
classes}.

%%% Naming conventions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{lll}
\hline
\hline
\noalign{\smallskip}
Method & Usage & Implementation \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt clear()} & Set object to initial empty state & all classes \\
{\tt clone()} & Provides a deep copy of the class & all classes \\
{\tt print()} & Print object into string & all classes (see section \ref{sec:output}) \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt append()} & Append element to list of elements & container classes (see section \ref{sec:containers}) \\
{\tt extend()} & Append container elements to list of elements & container classes (see section \ref{sec:containers}) \\
{\tt insert()} & Insert element to list of elements & container classes (see section \ref{sec:containers}) \\
{\tt pop()} & Remove element from list of elements & container classes (see section \ref{sec:containers}) \\
{\tt reserve()} & Reserve memory for a number of elements (see section \ref{sec:containers}) \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt load()} & Load data from file (open, read, close) & if applicable \\
{\tt save()} & Save data into file (open, write, close) & if applicable \\
{\tt open()} & Open file & if applicable \\
{\tt read()} & Read data from open file & if applicable \\
{\tt write()} & Write data into open file & if applicable \\
{\tt close()} & Close file & if applicable \\
{\tt name()} & Name of object & if applicable \\
{\tt type()} & Type of object & if applicable \\
{\tt size()} & Size of object & if applicable \\
{\tt real()} & Returns {\tt double} precision value & if applicable \\
{\tt integer()} & Returns {\tt int} value & if applicable \\
{\tt string()} & Returns {\tt std::string} value & if applicable \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note the difference between {\tt load()} and {\tt read()} and between {\tt save()} and {\tt write()}.
The {\tt load()} and {\tt save()} methods should take as arguments a file name, and they
will open the file, read or write some data, and then close the file.
In contrast, {\tt read()} and {\tt write()} will operate on files that are already open, and after
the read or write operation the files will remain open.
Typically, these methods take a {\tt GFits*} or a {\tt GFitsHDU*} pointer as argument.

Methods that perform checks should return a {\tt bool} type and should start with the
prefix {\tt is} or {\tt has}.
Examples are:
\begin{verbatim}
islong()
isin()
hasedisp()
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Method const declarations}

All methods that do not alter accessible class members should be declared {\tt const}.
With accessible we mean here class members that can be read or written in some
way by one of the methods.
Non-accessible class members would be members that are only used internally, and
for which no consistent state has to be preserved for the outside world.
These could for example be members that hold pre-computed values.

Methods that do not alter accessible members, but that modify non-accessible
members, should also be declared {\tt const}.
The non-accessible class members need then to be declared {\tt mutable} to avoid
compiler errors.
Alternatively, the {\tt const\_cast} declaration can be used to allow member modifications
within a {\tt const} method.

As example we show here part of the definition of {\tt GModelSpectralPlaw2}:
\begin{verbatim}
class GModelSpectralPlaw2 : public GModelSpectral {
public:
    virtual double eval(const GEnergy& srcEng) const;
    virtual void   read(const GXmlElement& xml);
protected:
    // Protected members
    GModelPar       m_integral;        //!< Integral flux
    GModelPar       m_index;           //!< Spectral index
    GModelPar       m_emin;            //!< Lower energy limit (MeV)
    GModelPar       m_emax;            //!< Upper energy limit (MeV)

    // Cached members used for pre-computations
    mutable double  m_log_emin;        //!< Log(emin)
    mutable double  m_log_emax;        //!< Log(emax)
    mutable double  m_pow_emin;        //!< emin^(index+1)
    mutable double  m_pow_emax;        //!< emax^(index+1)
    mutable double  m_norm;            //!< Power-law normalization (for pivot energy 1 MeV)
    mutable double  m_g_norm;          //!< Power-law normalization gradient
    mutable double  m_power;           //!< Power-law factor
    mutable double  m_last_integral;   //!< Last integral flux
    mutable double  m_last_index;      //!< Last spectral index (MeV)
    mutable double  m_last_emin;       //!< Last lower energy limit (MeV)
    mutable double  m_last_emax;       //!< Last upper energy limit (MeV)
    mutable GEnergy m_last_energy;     //!< Last source energy
    mutable double  m_last_value;      //!< Last function value
    mutable double  m_last_g_integral; //!< Last integral flux gradient
    mutable double  m_last_g_index;    //!< Last spectral index gradient
\end{verbatim}
This class has an internal cache for precomputation, which is potentially updated when
{\tt eval} is called.
Here the corresponding code:
\begin{verbatim}
double GModelSpectralPlaw2::eval(const GEnergy& srcEng) const
{
    // Update precomputed values
    update(srcEng);

    // Compute function value
    double value = integral() * m_norm * m_power;

    // Return
    return value;
}
\end{verbatim}
As the pre-computation cache is not exposed to the external world but fully handled within
the class, {\tt eval()} is declared {\tt const} as it does not modify any of the model parameters
(which are {\tt m\_integral}, {\tt m\_index}, {\tt m\_emin}, and {\tt m\_emax}).
It may however modified some of the cache members, that's why these members are
declared {\tt mutable}.
As there is however no way to access these cache values from the outside (no method exists
to access them), the {\tt eval()} method does not modify any {\em observable} property of the class,
hence it is declared {\tt const}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Method arguments and return values}

%True/false checks should always be done using {\tt bool}.

If possible, method arguments should always be passed by reference.
To protect references from changes by the method, {\bf arguments passed by reference
should always be declared {\tt const}}.
Pointers should only be used as arguments if {\tt NULL} should be a possible
argument value.
Also pointers should always be declared {\tt const}.
Here an example based on the definition of {\tt GObservation}:
\begin{verbatim}
class GObservation {
public:
    void                  events(const GEvents* events);
    void                  statistics(const std::string& statistics);
protected:
    std::string m_statistics;   //!< Optimizer statistics (default=poisson)
    GEvents*    m_events;       //!< Pointer to event container
};
\end{verbatim}
The {\tt statictics} value is passed by reference because the class will hold the actual
value, while {\tt events} is passed as a pointer because the class will hold the
pointer.

Numeric argument types should be either {\tt int} or {\tt double}.
Unless absolutely necessary, avoid {\tt short int}, {\tt long}, and {\tt float}.

If a method returns a class member, the return value should be passed by reference.
Unless we explicitly want to modify a class member through the method call,
return values passed by reference should be declared {\tt const}.

If a method returns a base class object, a pointer should be returned.
{\bf Do never return base class objects by reference, as this will lead to
code slicing if the method is used for object assignment.}
Unless we explicitly want to modify a class member through the method call,
the returned pointer should be declared {\tt const}.

Here an example based on the definition of {\tt GObservation}:
\begin{verbatim}
class GObservation {
public:
    virtual double        ontime(void) const = 0;
    const GEvents*        events(void) const;
    const std::string&    statistics(void) const { return m_statistics; }
protected:
    std::string m_statistics;   //!< Optimizer statistics (default=poisson)
    GEvents*    m_events;       //!< Pointer to event container
};
\end{verbatim}
The {\tt ontime()} method does return a double by value as the ontime property is not
stored explicitly in the class (hence no reference can be returned to it).
On the other hand, the {\tt statistics()} method returns by reference as the statistics
property is stored as a data member (hence a reference can be returned).
Although we could have returned a reference to the event container, this would lead
to code slicing.
Therefore, the {\tt events()} method returns a pointer.
All returned references or pointers are declared {\tt const} to prevent modification of
class members.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Container classes}
\label{sec:containers}

Container classes are classes that contain list of elements.
Two cases are distinguished here: containers holding objects, and containers holding
pointers to objects.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Containers holding objects}

Containers holding objects should have element access operators {\tt operator[]} implemented
that return container elements by reference.
A non-const and a const version of the operator should exist.
Eventually, {\tt at()} methods could be added that always perform range checking.
Here is a list of mandatory methods for container classes holding objects:

%%% Mandatory methods for container classes %%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{ll}
\hline
\hline
\noalign{\smallskip}
Method & Usage \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt e\& operator[](const int\&)} & Element access operator \\
{\tt const e\& operator[](const int\&) const} & Element access operator \\
{\tt void clear()} & Delete all objects in container \\
{\tt void size()} & Return number of elements in container \\
{\tt void append(const e\&)} & Append an element to the container \\
{\tt void insert(const int\&, const e\&)} & Insert an element into the container \\
{\tt void extend(const C\&)} & Append another container to the container \\
{\tt void pop(const int\&)} & Removes an element from the container \\
{\tt void reserve(const int\&)} & Reserve memory space in a container \\
{\tt std::string print()} & Print container (see section \ref{sec:output}) \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Containers holding pointers}

Containers holding pointers different from those holding objects in that their {\tt operator[]}
operators return a pointer, and in that they implement a {\tt set()} method for value setting.
Here is a list of mandatory methods for container classes holding pointers:

%%% Mandatory methods for container classes %%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{ll}
\hline
\hline
\noalign{\smallskip}
Method & Usage \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt e* operator[](const int\&)} & Element access operator \\
{\tt const e* operator[](const int\&) const} & Element access operator \\
{\tt void set(const int\&, const e\&)} & Set an element of the container \\
{\tt void clear()} & Delete all objects in container \\
{\tt void size()} & Return number of elements in container \\
{\tt void append(const e\&)} & Append an element to the container \\
{\tt void insert(const int\&, const e\&)} & Insert an element into the container \\
{\tt void extend(const C\&)} & Append another container to the container \\
{\tt void pop(const int\&)} & Removes an element from the container \\
{\tt std::string print()} & Print container (see section \ref{sec:output}) \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Output}
\label{sec:output}

Output stream and logging operators should be implemented for every class as friend
operators (see section \ref{sec:header}).
The usage of friend operators (instead of member operators) allows for correct handling
of code such as
\begin{verbatim}
log << std::endl << "This is a text" << std::endl;
\end{verbatim}
To support these friend operators (and to support also the Python interface), each class
should have a {\tt print()} method:
\begin{verbatim}
std::string print(void) const;
\end{verbatim}
Using the {\tt print()} method the output operators will take the following generic form:
\begin{verbatim}
std::ostream& operator<< (std::ostream& os, const GFits& fits)
{
    os << fits.print();
    return os;
}
GLog& operator<< (GLog& log, const GFits& fits)
{
    log << fits.print();
    return log;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Exceptions}
\label{sec:exceptions}

Exceptions are largely used in \this\ to handle the occurrence of unexpected events.
\this\ exceptions are implement by the {\tt GException} class.
For each new exception type, a new exception subclass is added.

Each exception returns the method name in which the exception occurs and an exception
message.
The exception message is generally build from values that are passed as arguments to the
exception constructor.

Below a list of conventions for implementing and using exceptions:
\begin{itemize}
\item Re-use existing exceptions as far as possible.
\item Pass exception arguments by reference.
\item Use exceptions only for events that cannot be handled by a method.
Do not use exceptions to check a value or a state. Implement appropriate methods instead.
\item Never use exceptions in a destructor.
\item De-allocate all memory that is not de-allocated by the destructor before throwing an
exception. 
\item Always catch exceptions by reference.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Python classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Container classes}

%TBW


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Miscellaneous
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Miscellaneous}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Version control}

\this\ applies a three-number version numbering scheme:
{\tt major\_revision-minor\_revision-patch}.

A {\tt major\_revision} of {\tt 00} indicates that the \this\ design is not yet frozen.
At this level, external interfaces of \this\ may change without notification, and no
interface control system is implemented.
The {\tt minor\_revision} tag will be incremented for each new release, signaling
that new features have become available.
The {\tt patch} tag will be incremented after correcting bugs that were reported
on releases.

Once the \this\ design is frozen, the {\tt major\_revision} number will be incremented 
to {\tt 01}.
From this moment on, external interfaces of \this\ will be under configuration control.
If existing external interfaces will be modified, the {\tt major\_revision} number will be
incremented.
At the same time, the {\tt libtool} version number of the \this\ will also be incremented.
The {\tt minor\_revision} number will be incremented if modifications and extensions
are backward compatible
As before, the {\tt patch} number will be incremented after correcting bugs that were 
reported on releases.

\end{document}

