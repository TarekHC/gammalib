%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GammaLib Coding and Design Conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions for manual package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\task}{\mbox{GammaLib}}
\newcommand{\this}{\mbox{\tt \task}}
\newcommand{\shorttype}{\mbox{CDC}}
\newcommand{\doctype}{\mbox{Coding and Design Conventions}}
\newcommand{\version}{\mbox{draft}}
\newcommand{\calendar}{\mbox{21 September 2012}}
\newcommand{\auth}{\mbox{J\"urgen Kn\"odlseder}}
\newcommand{\approv}{\mbox{J\"urgen Kn\"odlseder}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}[12pt,a4]
\usepackage{epsfig}
\usepackage{manual}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin of document body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frontpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

This document summarises the coding and design conventions that should be following for
the \this\ development.

Respecting uniform and coherent coding and design conventions is crucial for software
development.
They improve code readability, ease code development and maintenance, ensure code
portability, and provide standards for the user interface.

Coding and design conventions were introduced at a very early stage of the \this\ project, and
are followed as strictly as possible.
The choices that were made for \this\ were inspired by a large survey of existing C++ coding
rules, combined with the experience of the leading code developers.
Obviously, there is no single best way to code in C++, and the adopted conventions may not
meet the coding usage of individual developers.
They should nevertheless be respected strictly, as the \this\ code base is already very large,
and assuring uniformity and coherence is a primary goal of the project.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% General coding rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General coding rules}

The following general rules should be followed:
\begin{itemize}
\item Blocks are indented by 4 characters.
\item Do not use tabs (code formatting should be independent of editor configurations).
\item Do not exceed a line length of 80 characters (a few more characters are in exceptional cases acceptable).
\item Put a blank line at the end of each file.
\end{itemize}

\begin{itemize}
\item Each function and/or method terminates with a {\tt return} statement.
\item Each function and/or method has only a single exit point (i.e. a single {\tt return} statement).
\item Use {\tt explicit} for constructors to avoid use of the constructor for unintended
type conversion.
\item Each function starts with a curly bracket in the line following the function name.
The return type is in the same line as the function name. Example:
\begin{verbatim}
void function(void)
{
    int = 0;
    return;
}
\end{verbatim}
\item Each block should be encompassed in curly brackets, even if it is a single line block.
The block starts in the same line as the related statement. Examples:
\begin{verbatim}
if (inx < 0 || inx >= m_num) {
    throw GException::out_of_range("GVector::operator(int)", inx, m_num);
}
\end{verbatim}
\begin{verbatim}
for (int i = 0; i < 10; ++i) {
    sum += i;
}
\end{verbatim}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coding style
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coding style}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Code configuration}

The code configuration is controlled via an include file that has to be added on top of
each source file.
Each source file should start with:

\begin{verbatim}
/* __ Includes ___________________________________________________________ */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
\end{verbatim}

Note that the {\tt config.h} file should {\bf not be included in header files}, since header file
are used by the outside world for which a different {\tt config.h} include file may exist.

One of the most common options used throughout \this\ is range checking.
Range checking is particularily important during code development since it allows to catch
memory leaks.
However, range checking is time consuming and thus leads to somewhat slower code.
Range checking can thus be disable during installation of \this\ by using
{\tt ./configure --disable-range-check} during library installation.
Within the code, the following instruction adds range checking that dependens on
the library configuration:

\begin{verbatim}
#if defined(G_RANGE_CHECK)
if (inx < 0 || inx >= m_num) {
    throw GException::out_of_range("GVector::operator(int)", inx, m_num);
}
#endif
\end{verbatim}

Range checking is provided if the {\tt G\_RANGE\_CHECK} macro is defined.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Header inclusions}

Each file should contain the {\tt \#include} directives that are necessary for compilation of
the specific file.
Only {\tt \#include} directives that are already given by the corresponding header file can
be omitted.

As \this\ is written in C++, the C++ style headers should be used instead of the C style
headers to ensure maximum portability.
Examples of common C++ style headers are
{\tt <cstdio>} (instead of {\tt <stdio.h>}),
{\tt <cmath>} (instead of {\tt <math.h>}),
{\tt <cstring>} (instead of {\tt <string.h>}), etc.
Functions and types should then be prefixed by {\tt std::}.
For example,
{\tt cos} becomes {\tt std::cos},
{\tt time\_t} becomes {\tt std::time\_t}, etc.
One significant change is that {\tt fabs} becomes {\tt std::abs} since
the C style {\tt abs} function only applies to integers.
Here, the {\tt std::} prefix is crucial to distinguish the C++ function (which is
also defined for doubles) from the C function.

Note also that some compilers are more tolerant in omitting {\tt \#include} directives, such
as {\tt <cstdio>} or {\tt <cstring>}, so these directives should also be included for compatibility,
even if they seem not to be required on specific systems.
Examples of include directives needed by common functions are:
\begin{itemize}
\item[] {\tt <cstdio>} contains {\tt std::fopen}, {\tt std::fgets}, {\tt std::fclose}, {\tt std::fprintf}, {\tt std::sprintf}
\item[] {\tt <cstring>} contains {\tt std::strncpy}, {\tt std::memcpy}
\end{itemize}

If possible, however, {\tt std::strncpy} and {\tt std::memcpy} should be avoided at all as these
functions happend to have some compatibility problems in the past.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Members}

Class members should be either {\tt private} or {\tt protected}, the latter being generally used
when a derived class should be able to access base class data.

Members should be prefixed by {\tt m\_} and should be in lower case.
For long member names, additional underscores may be added.
Examples of valid member names are
\begin{verbatim}
  m_num
  m_response
  m_grid_length
  m_axis_dir_qual
\end{verbatim}

Initialisation, copying and deleting of class members should be gathered in a single
place to avoid memory leaks.
For this purpose, each C++ class should have the following {\tt private} or {\tt protected}
methods for memory management:
\begin{itemize}
\item {\tt init\_members()} initializes all member variables and pointers to well defined
initial values. The class should be fully operational and consistent with these initial
values. All pointers that will hold dynamically allocated memory should be
initialised to {\tt NULL}.
\item {\tt copy\_members(const \&A a)} copies all members from one instance {\tt a}
to the {\tt this} instance.
\item {\tt free\_members()} frees all memory that has been allocated by the class.
Memory pointers should be set to {\tt NULL} after the memory was deleted to signal
that no valid memory is associated to the pointer.
This allows for checking if memory has been allocated before it is accessed.
\end{itemize}
(in the above notation, {\tt A} is the class name and {\tt a} is an instance of the class).

An example for valid {\tt init\_members()}, {\tt copy\_members(const \&A a)} and
{\tt free\_members()} methods is:
\begin{verbatim}
void GEbounds::init_members(void)
{
    m_num = 0;
    m_min = NULL;
    m_max = NULL;
    return;
}

void GEbounds::copy_members(const GEbounds& ebds)
{
    m_num  = ebds.m_num;
    if (m_num > 0) {
        m_min = new GEnergy[m_num];
        m_max = new GEnergy[m_num];
        for (int i = 0; i < m_num; ++i) {
            m_min[i] = ebds.m_min[i];
            m_max[i] = ebds.m_max[i];
        }
    }
    return;
}

void GEbounds::free_members(void)
{
    if (m_min != NULL) delete [] m_min;
    if (m_max != NULL) delete [] m_max;
    m_min = NULL;
    m_max = NULL;
    return;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Constructors, destructors and operators}

Each class should have at least a void constructor, a copy constructor, a destructor and
an assignment operator.
Additional constructors and operators can be implemented as required.
The following example shows the basic implementation for these 4 methods.
Due to the usage of the {\tt init\_members()}, {\tt copy\_members(const \&A a)} and the
{\tt free\_members()} methods, most classes will have exactly this kind of syntax:
\begin{verbatim}
GEbounds::GEbounds(void)
{
    init_members();
    return;
}

GEbounds::GEbounds(const GEbounds& ebds)
{
    init_members();
    copy_members(ebds);
    return;
}

GEbounds::~GEbounds(void)
{
    free_members();
    return;
}

GEbounds& GEbounds::operator= (const GEbounds& ebds)
{
    if (this != &ebds) {
        free_members();
        init_members();
        copy_members(ebds);
    }
    return *this;
}
\end{verbatim}
Note that for a derived class, the assignment operator will have the form:
\begin{verbatim}
GEventCube& GEventCube::operator= (const GEventCube& cube)
{
    if (this != &cube) {
        this->GEvents::operator=(cube);    // Copy base class members
        free_members();
        init_members();
        copy_members(cube);
    }
    return *this;
}
\end{verbatim}
Also note that {\bf for a derived class, {\tt init\_members()}, {\tt copy\_members(const \&A a)}
and {\tt free\_members()} should only act on derived class members but not on
base class members}.
Any exception from this rule needs very careful documentation since it can easily be
the source of memory leaks.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inheritence}

Class inheritence is heavily used in \this\ to implement instrument specific functionnalities
that satisfy a generic interface.

Derived classes should never set explicitely base class members.
Base class members should be set by proper constructors, and base class constructors are
to to be invoked in derived class constructors.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Methods}

Uniform {\tt public} method names should be provided throughout \this\ for all classes.
Unless the {\tt public} method names are very long (which should be avoided), names
should not comprise underscores as separators.
{\tt Public} method names are all lowercase.

{\tt Private} or {\tt protected} may differ from this since they are hidden within the class.
Yet also here, all method names should be lowercase, and the use of underscores
should be limited.
 
In addition, the following {\tt public} method names should be used:

%%% Naming conventions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!h]
\caption{Naming conventions for class methods.
\label{tab:naming}}
\begin{center}
\begin{tabular}{lll}
\hline
\hline
\noalign{\smallskip}
Method & Usage & Implementation \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt clear()} & Set object to initial empty state & all classes \\
{\tt print()} & Print object into string & all classes (see section \ref{sec:output}) \\
{\tt append()} & Append element to list of elements & container classes \\
{\tt size()} & Return number of elements in object & container classes \\
{\tt load()} & Load data from file (open, read, close) & if applicable \\
{\tt save()} & Save data into file (open, write, close) & if applicable \\
{\tt read()} & Read data from open file & if applicable \\
{\tt write()} & Write data into open file & if applicable \\
{\tt name()} & Name of object & if applicable \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note the difference between {\tt load()} and {\tt read()} and between {\tt save()} and {\tt write()}.
The {\tt load()} and {\tt save()} methods should take as arguments a file name, and they
will open the file, read or write some data, and then close the file.
In contrast, {\tt read()} and {\tt write()} will operate on files that are already open, and after
the read or write operation the files will remain open.
Typically, these methods take a {\tt GFits*} or a {\tt GFitsHDU*} pointer as argument.

Methods that perform checks should return a {\tt bool} type and should start with the
prefix {\tt is} or {\tt has}.

Valid examples are:
\begin{verbatim}
  islong()
  isin()
  hasedisp()
\end{verbatim}

Method arguments should be generally passed as {\tt const} and by reference.

Numeric argument types should be typically {\tt int} and {\tt double}.
Unless absolutely required, {\tt short int}, {\tt long}, and {\tt float} should be avoided.
True/false checks should always be done using {\tt bool}.

Methods should be declared as {\tt const} if they do not alter class members.
In some classes, pre-computations are done to speed up calculations, and these
pre-computations will alter class members.
If these pre-computation are not supposed to alter the content of a class,
methods that perform pre-computations should also be declared as {\tt const}.
Internally, they have to circumvent const correctness by casting the pointer to
non {\tt const} or by using the {\tt mutable} attribute in the declaration of the members
that hold the pre-computed values (the latter option is preferred).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Method arguments and return values}

Arguments to methods should in general be passed by reference to reduce function
overhead.
In addition, arguments that are not intended to be changed by a method call should
be passed as {\tt const}.
Return values should also be passed by reference.
To assure that the return values will not change class members inadvertably, return
values passed by reference should also be declared as {\tt const}.

If the class member is a pointer, the argument should also be a pointer to allow
setting the pointer to {\tt NULL}.
The exception to this are container classes which in general do not contain
{\tt NULL} pointers in the container.

Return values should be passed by reference if they concern class members.

If the class member is a pointer, and if the pointer may be {\tt NULL}, it should be
returned as a pointer.
Again, the pointer should be declared {\tt const} to avoid inadvertable changes of
the class members.
The exception to this are container classes which in general do not contain
{\tt NULL} pointers in the container.
Container classes should return references to container elements.

An example is given by the following excerpt of the {\tt GObservation} class.
Note that in general there are two distinct methods to set and to return a
class member.
\begin{verbatim}
    void               obsname(const std::string& obsname);
    void               ebounds(const GEbounds& ebounds);
    void               gti(const GGti& gti);
    void               roi(const GRoi* roi);
    void               events(const GEvents* events);
    void               statistics(const std::string& statistics);
    const std::string& obsname(void) const;
    GTime              tstart(void) const { return m_gti.tstart(); }  // no class member
    GTime              tstop(void) const { return  m_gti.tstop(); }   // no class member
    GEnergy            emin(void) const { return m_ebounds.emin(); }  // no class member
    GEnergy            emax(void) const { return m_ebounds.emax(); }  // no class member
    const GEbounds&    ebounds(void) const;
    const GGti&        gti(void) const;
    const GRoi*        roi(void) const;
    const GEvents*     events(void) const;
    const std::string& statistics(void) const;
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Output}
\label{sec:output}

Output stream and logging operators should be implemented for every class as friend
operators.
An example is:
\begin{verbatim}
#include <iostream>
#include "GLog.hpp"
class GFits {
    friend std::ostream& operator<< (std::ostream& os, const GFits& fits);
    friend GLog&         operator<< (GLog& log, const GFits& fits);
    ...
\end{verbatim}
The usage of friend operators (instead of member operators) allows for correct handling
of code such as
\begin{verbatim}
log << std::endl << "This is a text" << std::endl;
\end{verbatim}
To support these friend operators (and to support also the Python interface), each class
should have a {\tt print()} method:
\begin{verbatim}
std::string print(void) const;
\end{verbatim}
Using the {\tt print()} method the output operators will take the following generic form:
\begin{verbatim}
std::ostream& operator<< (std::ostream& os, const GFits& fits)
{
    os << fits.print();
    return os;
}
GLog& operator<< (GLog& log, const GFits& fits)
{
    log << fits.print();
    return log;
}
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python classes}

TBW

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Design Conventsions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design Conventions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++ classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Container classes}

Container classes are classes that contain list of elements.

Each container class should have element access operators {\tt operator[]} implemented,
returning either a reference or a pointer to the class elements.
A non-const and a const version of the operator should exist.

Similar to the C++ template classes, {\tt at()} methods could also be implemented that
perform range checking.

%%% Mandatory methods for container classes %%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{table}[!h]
%\caption{Mandatory methods for container classes holding a list of elements.
%{\tt e} designates the type of a container element,
%{\tt C} designates the type of the container.
%\label{tab:containers}}
\begin{center}
\begin{tabular}{ll}
\hline
\hline
\noalign{\smallskip}
Method & Usage \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt e\& operator[](const int\&)} & Element access operator \\
{\tt const e\& operator[](const int\&) const} & Element access operator \\
{\tt void clear()} & Delete all objects in container \\
{\tt void size()} & Return number of elements in container \\
{\tt void append(const e\&)} & Append an element to the container \\
{\tt void insert(const int\&, const e\&)} & Insert an element into the container \\
{\tt void extend(const C\&)} & Append another container to the container \\
{\tt void pop(const int\&)} & Removes an element from the container \\
{\tt std::string print()} & Print container (see section \ref{sec:output}) \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

TBW: Specific note about containers of pointers.

%%% Mandatory methods for container classes %%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{table}[!h]
%\caption{Mandatory methods for container classes holding a list of element pointers.
%{\tt e} designates the type of a container element,
%{\tt C} designates the type of the container.
%\label{tab:ptrcontainers}}
\begin{center}
\begin{tabular}{ll}
\hline
\hline
\noalign{\smallskip}
Method & Usage \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
{\tt e* operator[](const int\&)} & Element access operator \\
{\tt const e* operator[](const int\&) const} & Element access operator \\
{\tt void set(const int\&, const e*)} & Set an element of the container \\
{\tt void clear()} & Delete all objects in container \\
{\tt void size()} & Return number of elements in container \\
{\tt void append(const e\&)} & Append an element to the container \\
{\tt void insert(const int\&, const e\&)} & Insert an element into the container \\
{\tt void extend(const C\&)} & Append another container to the container \\
{\tt void pop(const int\&)} & Removes an element from the container \\
{\tt std::string print()} & Print container (see section \ref{sec:output}) \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
%\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Container classes}

TBW


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Documentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Documentation}

Code documentation should be done within the source files using Doxygen
compliant annotations.

The following rules apply.


\subsection{File descriptor}

Put a 80 character wide header comment on top of {\bf each file}
(header, source code, templates, etc.).
The header contains
the file name,
a brief description of the file content,
the development period and the name of the person which {\bf initially}
created the file, and
a standard GNU Public License statement.
The header comment is immediately followed by a Doxygen compliant
file description that provides
the file name,
a brief description of the file content, and
the name of the person which {\bf initially} created the file.
\begin{verbatim}
/***************************************************************************
 *                       GMatrix.cpp  -  matrix class                      *
 * ----------------------------------------------------------------------- *
 *  copyright (C) 2006-2010 by Jurgen Knodlseder                           *
 * ----------------------------------------------------------------------- *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
/**
 * @file GMatrix.cpp
 * @brief GVector class implementation.
 * @author J. Knodlseder
 */
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Miscellaneous
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Miscellaneous}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Version control}

\this\ applies a three-number version numbering scheme:
{\tt major\_revision-minor\_revision-patch}.

A {\tt major\_revision} of {\tt 00} designates the development version of \this.
At this level, external interfaces of \this\ may change constantly, hence no
interface control system is implemented.
The {\tt minor\_revision} tag will be incremented once new major features become
available.
The {\tt patch} tag will be incremented after adding minor features and code corrections.

Once the development phase is finished the release phase is entred.
At this moment the {\tt major\_revision} number will be incremented to {\tt 01}.

During release phase, external interfaces of \this\ will be under configuration control.
If modifications of existing external interfaces will be done, the {\tt major\_revision}
number will be incremented.
At the same time, the {\tt libtool} version number of the \this\ will also change.

The {\tt minor\_revision} number will be incremented in the release phase when
extensions of the existing interfaces get implemented.
Extensions should always be backward compatible, i.e. any existing software should
not break due to the add of extensions.

The {\tt patch} number will be incremented in the release phase after bug corrections
or code improvements.
The corresponding modifications should not change the functionality of the library.

\end{document}

