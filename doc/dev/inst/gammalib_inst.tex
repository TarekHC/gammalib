%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GammaLib Instrument Specific Interface
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions for manual package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\task}{\mbox{GammaLib}}
\newcommand{\this}{\mbox{\tt \task}}
\newcommand{\shorttype}{\mbox{INST}}
\newcommand{\doctype}{\mbox{Instrument specific interface}}
\newcommand{\version}{\mbox{draft}}
\newcommand{\calendar}{\mbox{27 May 2010}}
\newcommand{\auth}{\mbox{J\"urgen Kn\"odlseder}}
\newcommand{\approv}{\mbox{J\"urgen Kn\"odlseder}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}[12pt,a4]
\usepackage{epsfig}
\usepackage{manual}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin of document body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frontpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The present document describes the instrument specific interface of the \this\ toolbox
and provides guideslines of how to add a new interface to the toolbox.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Instrument response
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Instrument response}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Response model}

The general instrument response function
$R(\vec{p'}, E', t' | \vec{d}, \vec{p}, E, t)$
provides the effective detection area per time, energy and solid angle
(in units of cm$^2$ s$^{-1}$ MeV$^{-1}$ sr$^{-1}$) 
for measuring a photon at position $\vec{p'}$ with an energy of $E'$ and at the time $t'$ if it 
arrives on the instrument that is pointed towards $\vec{d}$ from direction $\vec{p}$ with an 
energy of $E$ at time $t$.
Note that $\vec{p'}$ is not necessarily a measured arrival direction, but it can also be
a detector coordinate.
$R(\vec{p'}, E', t' | \vec{d}, \vec{p}, E, t)$ is factorised following
\begin{eqnarray}
R(\vec{p'}, E', t' | \vec{d}, \vec{p}, E, t) = 
L(\vec{d}, \vec{p}, E, t) \times
A_{\rm eff}(\vec{d}, \vec{p}, E, t) \times
PSF(\vec{p'} | \vec{d}, \vec{p}, E, t) \times
E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t) \times \nonumber \\
T_{\rm disp}(t' | \vec{d}, \vec{p}, E, t)
\label{eq:rspfact}
\end{eqnarray}
where
\begin{itemize}
\item[] $L(\vec{d}, \vec{p}, E, t)$ is the livetime fraction (in units of s s$^{-1}$),
\item[] $A_{\rm eff}(\vec{d}, \vec{p}, E, t)$ is the effective area (in units of counts photons$^{-1}$cm$^2$),
\item[] $PSF(\vec{p'} | \vec{d}, \vec{p}, E, t)$ is the point spread function (in units of sr$^{-1}$),
\item[] $E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t)$ is the energy dispersion (in units of MeV$^{-1}$), and
\item[] $T_{\rm disp}(t' | \vec{d}, \vec{p}, E, t)$ is the time dispersion (in units of s$^{-1}$).
\end{itemize}
Assuming that the photon intensity received from a gamma-ray source is described by
the source model $S(\vec{p}, E, t)$ (in units of photons cm$^{-2}$ s$^{-1}$ MeV$^{-1}$ sr$^{-1}$)
the probability of measuring an event at position $\vec{p'}$ with an
energy of $E'$ at the time $t'$ from the source is given by
\begin{equation}
N(\vec{p'}, E', t'| \vec{d}) = \int_{0}^{t'+\Delta t} \int_{E'-\Delta E}^{\infty} \int_{\Omega} 
S(\vec{p}, E, t) \times R(\vec{p'}, E', t' | \vec{d}, \vec{p}, E, t) \, {\rm d}\vec{p} \, {\rm d}E \,{\rm d}t
\label{eq:model}
\end{equation}
(in units of counts s$^{-1}$ MeV$^{-1}$ sr$^{-1}$).
The terms $\Delta t$ and $\Delta E$ account for the statistical jitter related to the measurement
process and are of the order of a few time the rms in the time and energy measurements.
In the case of no time dispersion, $T_{\rm disp}(t' | \vec{d}, \vec{p}, E, t)$ becomes a $\delta$-function
and Eq.~(\ref{eq:model}) reduces to 
\begin{eqnarray}
N(\vec{p'}, E', t' | \vec{d}) = \int_{E'-\Delta E}^{\infty} \int_{\Omega} 
S(\vec{p}, E, t') \times 
L(\vec{d}, \vec{p}, E, t') \times
A_{\rm eff}(\vec{d}, \vec{p}, E, t') \times
PSF(\vec{p'} | \vec{d}, \vec{p}, E, t') \times \nonumber \\
E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t') 
\, {\rm d}\vec{p} \, {\rm d}E \, .
\end{eqnarray}
Since for many astrophysical sources $S(\vec{p}, E, t)$ drops quickly with energy, only
photons near $E'$ contribute effectively to the integral.
For this reason, energy dispersion can also often be neglected, and also
$E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t)$ can be approximated by a $\delta$-function,
leading to
\begin{equation}
N(\vec{p'}, E', t'| \vec{d}) = \int_{\Omega} 
S(\vec{p}, E', t') \times 
L(\vec{d}, \vec{p}, E', t') \times
A_{\rm eff}(\vec{d}, \vec{p}, E', t') \times
PSF(\vec{p'} | \vec{d}, \vec{p}, E', t') \, {\rm d}\vec{p} \, .
\end{equation}
These simplifications may be considered when implementing the computation of
$N(\vec{p'}, E', t' | \vec{d})$ for a specific instrument.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Total number of predicted events}

The total number of predicted events for a given pointing $\vec{d}$ is given by
\begin{equation}
N_{\rm pred} = \int_{\rm GTI} \int_{E_{\rm min}}^{E_{\rm max}} \int_{\rm ROI} 
N(\vec{p'}, E', t' | \vec{d}) \, {\rm d}\vec{p'} \, {\rm d}E' \,{\rm d}t'
\end{equation}
where
${\rm ROI}$ is the event selection region,
$E_{\rm min}$ and $E_{\rm max}$ are the event selection energy boundaries, and
${\rm GTI}$ are the good time intervals.
Using Eq.~(\ref{eq:model}), $N_{\rm pred}$ can be written as
\begin{eqnarray}
N_{\rm pred} = \int_{0}^{\infty} \int_{0}^{\infty} \int_{\Omega} 
S(\vec{p}, E, t) \times 
L(\vec{d}, \vec{p}, E, t) \times
A_{\rm eff}(\vec{d}, \vec{p}, E, t) \times
N_{\rm PSF}(\vec{d}, \vec{p}, E, t) \times
N_{\rm Edisp}(\vec{d}, \vec{p}, E, t) \times \nonumber \\
N_{\rm Tdisp}(\vec{d}, \vec{p}, E, t) 
\, {\rm d}\vec{p} \, {\rm d}E \, \,{\rm d}t
\label{eq:npred}
\end{eqnarray}
where the three integrals are to be taken over all possible photon arrival times $t$, 
true energies $E$, and arrivial directions $\vec{p}$.
The integrations over the data selection regions (${\rm ROI}$, $E_{\rm min}$ and $E_{\rm max}$,
${\rm GTI}$) have been written as
\begin{equation}
N_{\rm PSF}(\vec{d}, \vec{p}, E, t) = \int_{\rm ROI} PSF(\vec{p'} | \vec{d}, \vec{p}, E, t) \, {\rm d}\vec{p'}
\end{equation}
\begin{equation}
N_{\rm Edisp}(\vec{d}, \vec{p}, E, t) = \int_{E_{\rm min}}^{E_{\rm max}} 
E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t) \, {\rm d}E'
\end{equation}
and
\begin{equation}
N_{\rm Tdisp}(\vec{d}, \vec{p}, E, t) = \int_{\rm GTI} T_{\rm disp}(t' | \vec{d}, \vec{p}, E, t) \, {\rm d}t' \, .
\end{equation}
By combining all terms related to the instrument response function in
\begin{equation}
N_{\rm R}(\vec{d}, \vec{p}, E, t) = 
L(\vec{d}, \vec{p}, E, t) \times
A_{\rm eff}(\vec{d}, \vec{p}, E, t) \times
N_{\rm PSF}(\vec{d}, \vec{p}, E, t) \times
N_{\rm Edisp}(\vec{d}, \vec{p}, E, t) \times
N_{\rm Tdisp}(\vec{d}, \vec{p}, E, t)
\end{equation}
Eq.~(\ref{eq:npred}) simplifies to
\begin{equation}
N_{\rm pred} = \int_{0}^{\infty} \int_{0}^{\infty} \int_{\Omega} 
S(\vec{p}, E, t) \times 
N_{\rm R}(\vec{d}, \vec{p}, E, t)
\, {\rm d}\vec{p} \, {\rm d}E \, \,{\rm d}t
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Factorized source model}

A special type of source model is given by the factorisation
\begin{equation}
S(\vec{p}, E, t) = M(\vec{p}) \times P(E) \times V(t)
\end{equation}
where
\begin{itemize}
\item[] $M(\vec{p})$ is a map of the intensity distribution (in units of sr$^{-1}$),
\item[] $P(E)$ is the source spectrum (in units of photons cm$^{-2}$ s$^{-1}$ MeV$^{-1}$), and
\item[] $V(t)$ is a source modulation function (unitless).
\end{itemize}
In this case, Eq.~(\ref{eq:model}) becomes

\begin{eqnarray}
N(\vec{p'}, E', t' | \vec{d}) = \int_{0}^{t'+\Delta t} \int_{E'-\Delta E}^{\infty} \int_{\Omega} 
M(\vec{p}) \times P(E) \times V(t) \times 
L(\vec{d}, \vec{p}, E, t) \times
A_{\rm eff}(\vec{d}, \vec{p}, E, t) \times \nonumber \\
PSF(\vec{p'} | \vec{d}, \vec{p}, E, t) \times
E_{\rm disp}(E' | \vec{d}, \vec{p}, E, t) 
T_{\rm disp}(t' | \vec{d}, \vec{p}, E, t) 
\, {\rm d}\vec{p} \, {\rm d}E \, {\rm d}t \, .
\end{eqnarray}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Implementation}

The \this\ implementation of the response function and parameters is summarised in 
Table \ref{tab:respar}.

%%% Response parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!h]
\caption{\this\ implementation of the response function and parameters. 
The last column indicates if the function or parameter requires an
instrument specific implementation (the corresponding class is an abstract base class
from which the implementation needs to be derived).
\label{tab:respar}}
\begin{center}
\begin{tabular}{lccc}
\hline
\hline
\noalign{\smallskip}
Response function or parameter & Designation & Class (::method) & Instrument specific \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
Response function & $R$ & {\tt GResponse::irf()} & possible \\
Lifetime fraction & $L$ & {\tt GResponse::live()} & {\bf yes} \\
Effective area & $A_{\rm eff}$ & {\tt GResponse::aeff()} & {\bf yes} \\
Point spread function & $PSF$ & {\tt GResponse::psf()} & {\bf yes} \\
Energy dispersion & $E_{\rm disp}$ & {\tt GResponse::edisp()} & {\bf yes} \\
Time dispersion & $T_{\rm disp}$ & {\tt GResponse::tdisp()} & {\bf yes} \\
Integral over response function & $N_{\rm R}$ & {\tt GResponse::nirf()} & possible \\
Integral over point spread function & $N_{\rm PSF}$ & {\tt GResponse::npsf()} & {\bf yes} \\
Integral over energy dispersion & $N_{\rm Edisp}$ & {\tt GResponse::nedisp()} & {\bf yes} \\
Integral over time dispersion & $N_{\rm Tdisp}$ & {\tt GResponse::ntdisp()} & {\bf yes} \\
Probability of measuring a photon & $N$ & {\tt GEvent::model()} & possible \\
Predicted number of events & $N_{\rm pred}$ & {\tt GObservation::npred()} & possible \\
Source model & $S$ & {\tt GModel} & no \\ 
Measured location of photon & $\vec{p'}$ & {\tt GInstDir} & {\bf yes} \\
Measured energy of photon & $E'$ & {\tt GEnergy} & no \\
Measured arrival time & $t'$ & {\tt GTime} & no \\
Instrument pointing & $d$ & {\tt GPointing} & {\bf yes} \\
True arrival direction of photon & $\vec{p}$ & {\tt GSkyDir} & no \\
True energy of photon & $E$ & {\tt GEnergy} & no \\
True arrival time of photon & $t$ & {\tt GTime} & no \\
Region of interets & ${\rm ROI}$ & {\tt GRoi} & {\bf yes} \\
Good Time Interval & ${\rm GTI}$ & {\tt GGti} & no \\
\noalign{\smallskip}
\hline
\end{tabular}
\end{center}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Response class {\tt GResponse}}

An instrument specific response class {\tt GXXXResponse} (where {\tt XXX} is the instrument code)
needs to be provided that derives from the abstract base class {\tt GResponse}.
The following sections provide a description of the methods and their interfaces that
must be implemented in {\tt GXXXResponse}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::irf()} (optional)}

Following the factorisation of the response (cf.~Eq.~\ref{eq:rspfact}) the standard implementation
of the {\tt GResponse::irf()} is given by the following code:
\begin{verbatim}
double GResponse::irf(const GInstDir& obsDir, const GEnergy& obsEng, const GTime& obsTime,
                      const GSkyDir& srcDir, const GEnergy& srcEng, const GTime& srcTime,
                      const GPointing& pnt) const
{
    double irf  =  live(srcDir,  srcEng, srcTime, pnt);
    irf        *=  aeff(srcDir,  srcEng, srcTime, pnt);
    irf        *=   psf(obsDir,  srcDir, srcEng, srcTime, pnt);
    irf        *= edisp(obsEng,  srcDir, srcEng, srcTime, pnt);
    irf        *= tdisp(obsTime, srcDir, srcEng, srcTime, pnt);
    return irf;
}
\end{verbatim}
This code is implemented in the {\tt GResponse::irf()} base class as a {\tt virtual} member and
{\bf needs not to be implemented in the derived instrument specific class.}
However, an instrument specific version may be provided as for example {\tt tdisp()} is rarely
needed and also {\tt edisp()} is often not used.
By omitting these terms a more efficient response calculation may be provided.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::live()}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::aeff()}}

Needs to be implemented and needs to return effective area in units of cm$^2$.
Interface:
\begin{verbatim}
double GXXXResponse::aeff(const GInstDir& obsDir, const GEnergy& obsEng, const GTime& obsTime,
                          const GSkyDir& srcDir, const GEnergy& srcEng, const GTime& srcTime,
                          const GPointing& pnt)
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::psf()}}

Needs to be implemented and needs to return point spread function in units of sr$^{-1}$.
Interface:
\begin{verbatim}
double GXXXResponse::psf(const GInstDir& obsDir, const GEnergy& obsEng, const GTime& obsTime,
                         const GSkyDir& srcDir, const GEnergy& srcEng, const GTime& srcTime,
                         const GPointing& pnt)
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::edisp()}}

Needs to be implemented and needs to return energy dispersion in units of MeV$^{-1}$.
Interface:
\begin{verbatim}
double GXXXResponse::edisp(const GInstDir* obsDir, const GEnergy& obsEng, const GTime& obsTime,
                          const GSkyDir& srcDir, const GEnergy& srcEng, const GTime& srcTime,
                          const GPointing* pnt)
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::tdisp()}}

Needs to be implemented and needs to return time dispersion in units of s$^{-1}$.
Interface:
\begin{verbatim}
double GXXXResponse::tdisp(const GInstDir& obsDir, const GEnergy& obsEng, const GTime& obsTime,
                          const GSkyDir& srcDir, const GEnergy& srcEng, const GTime& srcTime,
                          const GPointing& pnt)
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::nirf()} (optional)}

\begin{verbatim}
double GResponse::nirf(const GSkyDir&  srcDir, const GEnergy& srcEng,
                       const GTime& srcTime, const GPointing& pnt) const
{
    double nirf  =   live(srcDir, srcEng, srcTime, pnt);
    nirf        *=   aeff(srcDir, srcEng, srcTime, pnt);
    nirf        *=   npsf(srcDir, srcEng, srcTime, pnt);
    nirf        *= nedisp(srcDir, srcEng, srcTime, pnt);
    nirf        *= ntdisp(srcDir, srcEng, srcTime, pnt);
    return nirf;
}
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::npsf()}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::nedisp()}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXResponse::ntdisp()}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Response support classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXInstDir}}

Needs to be implemented.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXRoi}}

Region in instrument directions.
Needs to be implemented.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{\tt GXXXPointing}}

Needs to be implemented.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Instrument data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Instrument data}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Events}

Data are comprised of events.
The are two types of events: event atoms and event bins.
Events are combined together in {\tt GEvents}.
{\tt GEvents} implements an iteration that allows iterating over event atoms or event bins
(the differenciation between both is transparent for the user).
{\tt GEvents} has an abstract method {\tt pointer(int index)} that returns a pointer to an
event.
This method, which has to be implement for each instrument, assigns information to
all events.
Note that in general, only a single event can be accessed at a time (any subsequent
class to the {\tt pointer()} method makes the old pointer invalid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Event classes {\tt GEventAtom} and {\tt GEventbin}}

The following methods can {\bf optionally} be implemented to compute $N(\vec{p'}, E', t')$
more efficiently that is done by the generic method {\tt GEvents::model()}.

\begin{verbatim}
GXXXEventAtom::model(GModels& models, GVector* gradient);
GXXXEventBin::model(GModels& models, GVector* gradient);
\end{verbatim}

\end{document}
