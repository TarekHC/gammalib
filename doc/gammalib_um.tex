%---------------------------------------------------------------------------- 
%                             GammaLib User Manual
%
% Version: 0.4
% Last modification: 30 November 2010
%----------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions for manual package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\task}{\mbox{GammaLib}}
\newcommand{\this}{\mbox{\tt \task}}
\newcommand{\version}{\mbox{0.4}}
\newcommand{\calendar}{\mbox{30 November 2010}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}[12pt,a4]
\usepackage{epsfig}
\usepackage{manual}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begin of document body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frontpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Overview}

\this\ is a machine-independent library of C++ classes for analysing gamma-ray astronomy
data.
The core of \this\ implements an abstract interface to gamma-ray observations,
provides services for reading and writing the data,
enables the analysis of multi-mission data,
and implements support for building ftools like analysis executables.
On top of this core library, instrument specific C++ classes implement the interfaces to
handle data and response functions of specific gamma-ray instruments.

The development of \this\ has been initiated by scientists from IRAP (Institut de Recherche
en Astrophysique et Plan\'etologie), an astrophysics laboratory of CNRS and of the University
Paul Sabatier situated in Toulouse, France.
\this\ is based on past experience gained in developing software for gamma-ray space
missions, such as
the COMPTEL telescope aboard {\em CGRO}, 
the SPI telescope aboard {\em INTEGRAL},
and the LAT telescope aboard {\em Fermi}.
Initial elements of \this\ can be found in the {\tt spi\_toolslib} that is part of the
Off-line Science Analysis (OSA) software distributed by ISDC for the science analysis 
of {\em INTEGRAL} data.
The development of \this\ is nowadays mainly driven by the advances in 
ground-based gamma-ray astronomy, and in particular by the development of the
CTA observatory.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting \this}

The latest version of the \this\ source code, documentation, and example programs are
available on the World-Wide Web from:
\begin{verbatim}
   https://sourceforge.net/projects/gammalib/
\end{verbatim}
Any questions, bug reports, or suggested enhancements related to \this\ should be submitted
via the {\em Tracker} or the
\begin{verbatim}
   gammalib-users@lists.sourceforge.net
\end{verbatim}
mailing list.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Prerequisites}

\this\ should compile on every modern Unix system without any need to install any
specific library.

To enable support for FITS file handling, however, the {\tt cfitsio} library from HEASARC
needs to be installed.
{\tt cfitsio} can be downloaded from
\begin{verbatim}
   http://heasarc.gsfc.nasa.gov/fitsio
\end{verbatim}
and detailed installation instructions can be found there.
If {\tt cfitsio} does not already exist on your system, we recommend installation of {\tt cfitsio}
in the default \this\ install directory as a shared library by typing:
\begin{verbatim}
> ./configure --prefix=/usr/local/gamma
> make shared
> make install
\end{verbatim}

\this\ can also benefit from the presence of the {\tt readline} library that provides line-editing
and history capabilities for text input (\this\ offers however also full functionality without having
{\tt readline} installed).
{\tt readline} can be downloaded from
\begin{verbatim}
  http://ftp.gnu.org/gnu/readline/
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing \this}

\this\ is built on Unix systems by typing:
\begin{verbatim}
> ./autogen.sh
> ./configure
> make
> make install
\end{verbatim}
at the operating system prompt.
The configuration command customizes the Makefiles for the particular system,
the {\tt make} command compiles the source files and builds the library, and
the {\tt make install} command installs the library in the install directory.
Type {\tt ./configure} and not simply {\tt configure} to ensure that the configuration
script in the current directory is run and not some other system-wide configuration
script.
By default, the install directory is set to
{\tt /usr/local/gamma}.
To change the install directory an optional {\tt --prefix} argument should be given,
for example:
\begin{verbatim}
> ./configure --prefix=/usr/local
\end{verbatim}
A full list of configuration options can be found using
\begin{verbatim}
> ./configure --help
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing \this}

\this\ should be tested by typing:
\begin{verbatim}
> make check
\end{verbatim}
This will execute an extensive testing suite that should terminate with
\begin{verbatim}
===================
All 14 tests passed
===================
\end{verbatim}
If an older version of \this\ exists already on the system one has to make sure that the
library in installed using {\tt make install} before executing the tests.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting started with \this}

In order to effectively use \this\ it is recommended that new users begin by reading the
\this\ Quick Start Guide.
It contains all basic information needed to write programs to analyse gamma-ray data.
{\bf TBW ...}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Example program}

{\bf TBD: Give a short example program here ...}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming Guidelines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programming guidelines}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\this\ definitions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GammaLib components
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\this\ components}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Observations}

The primary user interface for the analysis of gamma-ray data is implemented by
the container class {\tt GObservations}.
{\tt GObservations} collects a list of gamma-ray observations which are the basic
entity used

The basic entity used for analysis of gamma-ray data is an observation.
{\bf TBW: Define what an observation is: single instrument, specific response function}.

An observation is implemented by the abstract {\tt GObservation} class that provides
the instrument independent interface to the data.

To combine several observation for an analysis, a list of {\tt GObservation} objects is
gather by the container class {\tt GObservations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Models}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optimizers}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Applications}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interfaces}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{FITS interface}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{XML interface}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Parameter interface}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Numerics}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Linear algebra}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Vectors}

%----------------------------------------------------------------------------
\paragraph{General}

A vector is a one-dimensional array of successive {\tt double} type values.
Vectors are handled in \this\ by {\tt GVector} objects.
On construction, the dimension of the vector has to be specified.
In other words
\begin{verbatim}
 GVector vector;                        // WRONG: constructor needs dimension
\end{verbatim}
is not allowed.
The minimum dimension of a vector is 1, i.e. there is no such thing 
like an empty vector:
\begin{verbatim}
 GVector vector(0);                     // WRONG: empty vector not allowed
\end{verbatim}
The correct allocation of a vector is done using
\begin{verbatim}
 GVector vector(10);                    // Allocates a vector with 10 elements
\end{verbatim}
On allocation, all elements of a vector are set to 0.
Vectors may also be allocated by copying from another vector
\begin{verbatim}
 GVector vector(10);                    // Allocates a vector with 10 elements
 GVector another = vector;              // Allocates another vector with 10 elements
\end{verbatim}
or by using 
\begin{verbatim}
 GVector vector = GVector(10);          // Allocates a vector with 10 elements
\end{verbatim}

Vector elements are accessed using the {\tt ( )} operator:
\begin{verbatim}
 GVector vector(10);                    // Allocates a vector with 10 elements
 for (int i = 0; i < 10; ++i)
   vector(i) = (i+1)*10.0;              // Set elements 10, 20, ..., 100
 for (int i = 0; i < 10; ++i)
   cout << vector(i) << endl;           // Dump all elements, one by row 
\end{verbatim}
The content of a vector may also be dumped using
\begin{verbatim}
 cout << vector << endl;                // Dump entire vector
\end{verbatim}
which in the above example will put the sequence
\begin{verbatim}
 10 20 30 40 50 60 70 80 90 100
\end{verbatim}
on the screen.


%----------------------------------------------------------------------------
\paragraph{Vector arithmetics}

Vectors can be very much handled like {\tt double} type variables
with the difference that operations are performed on each element of 
the vector.
The complete list of fundamental vector operators is:
\begin{verbatim}
 c = a + b;                             // Vector + Vector addition
 c = a + s;                             // Vector + Scalar addition
 c = s + b;                             // Scalar + Vector addition
 c = a - b;                             // Vector - Vector subtraction
 c = a - s;                             // Vector - Scalar subtraction
 c = s - b;                             // Scalar - Vector subtraction
 s = a * b;                             // Vector * Vector multiplication (dot product)
 c = a * s;                             // Vector * Scalar multiplication
 c = s * b;                             // Scalar * Vector multiplication
 c = a / s;                             // Vector * Scalar division
\end{verbatim}
where {\tt a}, {\tt b} and {\tt c} are of type {\tt GVector} and 
{\tt s} is of type {\tt double}.
Note in particular the combination of {\tt GVector} and {\tt double} 
type objects in addition, subtraction, multiplication and division.
In these cases the specified operation is applied to each of the 
vector elements.
It is also obvious that only vector of identicial dimension can occur 
in vector operations.
Dimension errors can be catched by the {\tt try} - {\tt catch} 
functionality:
\begin{verbatim}
 try {
   GVector a(10);                       
   GVector b(11);
   GVector c = a + b;                   // WRONG: Vectors have incompatible dimensions
 }
 catch (GVector::vector_mismatch &e) {
   cout << e.what() << endl;            // Dimension exception is catched here
   throw;
 }
\end{verbatim}
Further vector operations are
\begin{verbatim}
 c = a;                                 // Vector assignment
 c = s;                                 // Scalar assignment
 s = c(index);                          // Vector element access
 c += a;                                // c = c + a;
 c -= a;                                // c = c - a;
 c += s;                                // c = c + s;
 c -= s;                                // c = c - s;
 c *= s;                                // c = c * s;
 c /= s;                                // c = c / s;
 c = -a;                                // Vector negation
\end{verbatim}
Finally, the comparison operators
\begin{verbatim}
 int equal   = (a == b);                // True if all elements equal
 int unequal = (a != b);                // True if at least one elements unequal
\end{verbatim}
allow to compare all elements of a vector. If all elements are
identical, the {\tt ==} operator returns true, otherwise false.
If at least one element differs, the {\tt !=} operator returns true, 
is all elements are identical it returns false.

In addition to the operators, the following mathematical functions 
can be applied to vectors:
\begin{verbatim}
    acos         atan         exp          sin          tanh
    acosh        atanh        fabs         sinh
    asin         cos          log          sqrt
    asinh        cosh         log10        tan
\end{verbatim}
Again, these functions should be understood to be applied element wise.
They all take a vector as argument and produce a vector as result.
For example
\begin{verbatim}
 c = sin(a);
\end{verbatim}
attributes the sine of each element of vector {\tt a} to vector 
{\tt c}.
Additional implemented functions are
\begin{verbatim}
 c = cross(a, b);                       // Vector cross product (for 3d only)
 s = norm(a);                           // Vector norm |a|
 s = min(a);                            // Minimum element of vector
 s = max(a);                            // Maximum element of vector
 s = sum(a);                            // Sum of vector elements
\end{verbatim}
Finally, a small number of vector methods have been implemented:
\begin{verbatim}
 int n = a.size();                      // Returns dimension of vector
 int n = a.non_zeros();                 // Returns number of non-zero elements in vector
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Matrixes}

%----------------------------------------------------------------------------
\paragraph{General}

A matrix is a two-dimensional array of {\tt double} type values, 
arranged in rows and columns.
Matrixes are handled in \this\ by {\tt GMatrix} objects and the 
derived classes {\tt GSymMatrix} and {\tt GSparseMatrix} (see section 
\ref{sec:matrix:storage}).
On construction, the dimension of the matrix has to be specified:
\begin{verbatim}
 GMatrix matrix(10,20);                 // Allocates 10 rows and 20 columns
\end{verbatim}
Similar to vectors, there is no such thing as a matrix without 
dimensions in \this.


%----------------------------------------------------------------------------
\paragraph{Matrix storage classes}
\label{sec:matrix:storage}

In the most general case, the {\tt rows} and {\tt columns} of a 
matrix are stored in a continuous array of 
${\tt rows} \times {\tt columns}$
memory locations.
This storage type is referred to as a {\em full matrix}, and is 
implemented by the class {\tt GMatrix}.
Operations on full matrixes are in general relatively fast, but 
memory requirements may be important to hold all the elements.
In general matrixes are stored by \this\ column-wise (or in 
column-major format).
For example, the matrix
\begin{verbatim}
    1  2  3  4  5
    6  7  8  9 10
   11 12 13 14 15 
\end{verbatim}
is stored in memory as
\begin{verbatim}
    |  1  6 11 |  2  7 12 |  3  8 13 |  4  9 14 |  5 10 15 |
\end{verbatim}

Many physical or mathematical problems treat with a subclass of 
matrixes that is symmetric, i.e. for which the element
{\tt (row,col)} is identical to the element {\tt (col,row)}.
In this case, the duplicated elements need not to be stored.
The derived class {\tt GSymMatrix} implements such a storage type.
{\tt GSymMatrix} stores the lower-left triangle of the matrix in 
column-major format.
For illustration, the matrix
\begin{verbatim}
    1  2  3  4
    2  5  6  7
    3  6  8  9
    4  7  9 10
\end{verbatim}
is stored in memory as
\begin{verbatim}
    |  1  2  3  4 |  5  6  7 |  8  9 | 10 |
\end{verbatim}
This divides the storage requirements to hold the matrix elements by 
almost a factor of two.

Finally, quite often one has to deal with matrixes that contain a 
large number of zeros.
Such matrixes are called {\em sparse matrixes}.
If only the non-zero elements of a sparse matrix are stored the memory 
requirements are considerably reduced.
This goes however at the expense of matrix element access, which has 
become now more complex.
In particular, filling efficiently a sparse matrix is a non-trivial 
problem (see section \ref{sec:matrix:filling}).
Sparse matrix storage is implemented in \this\ by the derived class 
{\tt GSparseMatrix}.
A {\tt GSparseMatrix} object contains three one-dimensional arrays to 
store the matrix elements: 
a {\tt double} type array that contains in continuous column-major order 
all non-zero elements, 
an {\tt int} type array that contains for each non-zero element the 
row number of its location, and
an {\tt int} type array that contains the storage location of the 
first non-zero element for each matrix column.
To illustrate this storage format, the matrix
\begin{verbatim}
    1  0  0  7
    2  5  0  0
    3  0  6  0
    4  0  0  8
\end{verbatim}
is stored in memory as 
\begin{verbatim}
    |  1  2  3  4 |  5 |  6 |  7  8 |  Matrix elements
    |  0  1  2  3 |  1 |  2 |  0  3 |  Row indices for all elements
    |  0          |  4 |  5 |  6    |  Storage location of first element of each column
\end{verbatim}
This example is of course not very economic, since the total number of 
Bytes used to store the matrix is 
$8 \times 8 + (8 + 4) \times 4 = 112$ Bytes, while a full $4 \times 4$
matrix is stored in
$(4 \times 4) \times 8 = 128$ Bytes (recall: a {\tt double} type 
values takes 8 Bytes, an {\tt int} type value takes 4 Bytes).
For realistic large systems, however, the gain in memory space can be 
dramatical.

The usage of the {\tt GMatrix}, {\tt GSymMatrix} and {\tt GSparseMatrix} 
classes is analoguous in that they implement basically all functions 
and methods in an identical way.
So from the semantics the user has not to worry about the storage 
class. 
However, matrix element access speeds are not identical for all 
storage types, and if performance is an issue (as it certainly always 
will be), the user has to consider matrix access more carefully
(see section \ref{sec:matrix:filling}).

Matrix allocation is performed using the constructors:
\begin{verbatim}
 GMatrix       A(10,20);                // Full 10 x 20 matrix
 GSymMatrix    B(10,10);                // Symmetric 10 x 10 matrix
 GSparseMatrix C(1000,10000);           // Sparse 1000 x 10000 matrix

 GMatrix       A(0,0);                  // WRONG: empty matrix not allowed
 GSymMatrix    B(20,22);                // WRONG: symmetric matrix requested
\end{verbatim}
In the constructor, the first argument specifies the number of rows, 
the second the number of columns: {\tt A(row,column)}.
A symmetric matrix needs of course an equal number of rows and columns.
And an empty matrix is not allowed.
All matrix elements are initialised to 0 by the matrix allocation.

Matrix elements are accessed by the {\tt A(row,col)} function,
where {\tt row} and {\tt col} start from 0 for the first row or column 
and run up to the number of rows or columns minus 1:
\begin{verbatim}
 for (int row = 0; row < n_rows; ++row) {
   for (int col = 0; col < n_cols; ++col)
     A(row,col) = (row+col)/2.0;        // Set value of matrix element
 }
 ...
 double sum2 = 0.0;
 for (int row = 0; row < n_rows; ++row) {
   for (int col = 0; col < n_cols; ++col)
     sum2 *= A(row,col) * A(row,col);   // Get value of matrix element
 }
\end{verbatim}

The content of a matrix can be visualised using
\begin{verbatim}
 cout << A << endl;                     // Dump matrix
\end{verbatim}


%----------------------------------------------------------------------------
\paragraph{Matrix arithmetics}

The following description of matrix arithmetics applies to all storage 
classes (see section \ref{sec:matrix:storage}).
The following matrix operators have been implemented in \this:
\begin{verbatim}
 C = A + B;                             // Matrix Matrix addition
 C = A - B;                             // Matrix Matrix subtraction
 C = A * B;                             // Matrix Matrix multiplication
 C = A * v;                             // Matrix Vector multiplication
 C = A * s;                             // Matrix Scalar multiplication
 C = s * A;                             // Scalar Matrix multiplication
 C = A / s;                             // Matrix Scalar division
 C = -A;                                // Negation
 A += B;                                // Matrix inplace addition
 A -= B;                                // Matrix inplace subtraction
 A *= B;                                // Matrix inplace multiplications
 A *= s;                                // Matrix inplace scalar multiplication
 A /= s;                                // Matrix inplace scalar division
\end{verbatim}
The comparison operators
\begin{verbatim}
 int equal   = (A == B);                // True if all elements equal
 int unequal = (A != B);                // True if at least one elements unequal
\end{verbatim}
allow to compare all elements of a matrix. 
If all elements are identical, the {\tt ==} operator returns true, 
otherwise false.
If at least one element differs, the {\tt !=} operator returns true, 
is all elements are identical it returns false.


%----------------------------------------------------------------------------
\paragraph{Matrix methods and functions}

A number of methods has been implemented to manipulate matrixes.
The method
\begin{verbatim}
 A.clear();                             // Set all elements to 0
\end{verbatim}
sets all elements to 0.
The methods
\begin{verbatim}
 int rows = A.rows();                   // Returns number of rows in matrix
 int cols = A.cols();                   // Returns number of columns in matrix
\end{verbatim}
provide access to the matrix dimensions, the methods
\begin{verbatim}
 double sum = A.sum();                  // Sum of all elements in matrix
 double min = A.min();                  // Returns minimum element of matrix
 double max = A.max();                  // Returns maximum element of matrix
\end{verbatim}
inform about some matrix properties.
The methods
\begin{verbatim}
 GVector v_row    = A.extract_row(row); // Puts row in vector
 GVector v_column = A.extract_col(col); // Puts column in vector
\end{verbatim}
extract entire rows and columns from a matrix.
Extraction of lower or upper triangle parts of a matrix into another
is performed using
\begin{verbatim}
 B = A.extract_lower_triangle();        // B holds lower triangle
 B = A.extract_upper_triangle();        // B holds upper triangle
\end{verbatim}
{\tt B} is of the same storage class as {\tt A}, except for the case 
that {\tt A} is a {\tt GSymMatrix} object. 
In this case, {\tt B} will be a full matrix of type {\tt GMatrix}.

The methods
\begin{verbatim}
 A.insert_col(v_col,col);               // Puts vector in column
 A.add_col(v_col,col);                  // Add vector to column
\end{verbatim}
inserts or adds the elements of a vector into a matrix column.
Note that no row insertion routines have been implemented (so far) 
since they would be less efficient (recall that all matrix types are 
stored in column-major format).

Conversion from one storage type to another is performed using
\begin{verbatim}
 B = A.convert_to_full();               // Converts A -> GMatrix
 B = A.convert_to_sym();                // Converts A -> GSymMatrix
 B = A.convert_to_sparse();             // Converts A -> GSparseMatrix
\end{verbatim}
Note that {\tt convert\_to\_sym()} can only be applied to a matrix that 
is indeed symmetric.

The transpose of a matrix can be obtained by using one of
\begin{verbatim}
 A.transpose();                         // Transpose method
 B = transpose(A);                      // Transpose function
\end{verbatim}

The absolute value of a matrix is provided by
\begin{verbatim}
 B = fabs(A);                           // B = |A|
\end{verbatim}


%----------------------------------------------------------------------------
\paragraph{Matrix factorisations}

A general tool of numeric matrix calculs is factorisation.

Solve linear equation {\tt Ax = b}.
Inverse a matrix (by solving successively {\tt Ax = e}, where {\tt e} 
are the unit vectors for all dimensions).

For symmetric and positive definite matrices the most efficient 
factorisation is the Cholesky decomposition.
The following code fragment illustrates the usage:
\begin{verbatim}
 GMatrix A(n_rows, n_cols};
 GVector x(n_rows};
 GVector b(n_rows};
 ...
 A.cholesky_decompose();                // Perform Cholesky factorisation
 x = A.cholesky_solver(b);              // Solve Ax=b for x
\end{verbatim}
Note that once the function {\tt A.cholesky\_decompose()} has been 
applied, the original matrix content has been replaced by its Cholesky 
decomposition.
Since the Cholesky decomposition can be performed inplace (i.e. 
without the allocation of additional memory to hold the result), the 
matrix replacement is most memory economic.
In case that the original matrix should be kept, one may either copy 
it before into another {\tt GMatrix} object or use the function
\begin{verbatim}
 GMatrix L = cholesky_decompose(A);
 x = L.cholesky_solver(b);
\end{verbatim}

A symmetric and positif definite matrix can be inverted using the 
Cholesky decomposition using
\begin{verbatim}
 A.cholesky_invert();                   // Inverse matrix using Cholesky fact.
\end{verbatim}
Alternatively, the function 
\begin{verbatim}
 GMatrix A_inv = cholesky_invert(A);
\end{verbatim}
may be used.

The Cholesky decomposition, solver and inversion
routines may also be applied to matrices that contain rows or
columns that are filled by zeros.
In this case the functions provide the option to (logically)
compress the matrices by skipping the zero rows and columns during
the calculation.

For compressed matrix Cholesky factorisation, only the non-zero rows 
and columns have to be symmetric and positive definite.
In particular, the full matrix may even be non-symmetric.


%----------------------------------------------------------------------------
\paragraph{Sparse matrixes}

The only exception that does not work is
\begin{verbatim}
 GSparseMatrix A(10,10);
 A(0,0) = A(1,1) = A(2,2) = 1.0;        // WRONG: Cannot assign multiple at once
\end{verbatim}
In this case the value {\tt 1.0} is only assigned to the last 
element, i.e. {\tt A(2,2)}, the other elements will remain
{\tt 0}.
This feature has to do with the way how the compiler translates
the code and how \this\ implements sparse matrix filling.
{\tt GSparseMatrix} provides a pointer for a new element to be 
filled.
Since there is only one such {\em fill pointer}, only one element can 
be filled at once in a statement.
{\bf So it is strongly advised to avoid multiple matrix element 
assignment in a single row.}
Better write the above code like
\begin{verbatim}
 GSparseMatrix A;
 A(0,0) = 1.0;
 A(1,1) = 1.0;
 A(2,2) = 1.0;
\end{verbatim}
This way, element assignment works fine.

Inverting a sparse matrix produces in general a full matrix, so the 
inversion function should be used with caution.
Note that a full matrix that is stored in sparse format takes roughly
twice the memory than a normal {\tt GMatrix} object.
If nevertheless the inverse of a sparse matrix should be examined, it 
is recommended to perform the analysis column-wise:
\begin{verbatim}
 GSparseMatrix A(rows,cols);            // Allocate sparse matrix
 GVector       unit(rows);              // Allocate vector
 ...
 A.cholesky_decompose();                // Factorise matrix

 // Column-wise solving the matrix equation
 for (int col = 0; col < cols; ++col) {
   unit(col) = 1.0;                     // Set unit vector
   GVector x = cholesky_solver(unit);   // Get column x of inverse
   ...
   unit(col) = 0.0;                     // Clear unit vector for next round
 }
\end{verbatim}


%----------------------------------------------------------------------------
\paragraph{Filling sparse matrixes}
\label{sec:matrix:filling}

The filling of a sparse matrix is a tricky issue since the storage
of the elements depends on their distribution in the matrix.
If one would know beforehand this distribution, sparse matrix filling
would be easy and fast.
In general, however, the distribution is not known a priori, and
matrix filling may become a quite time consuming task.

If a matrix has to be filled element by element, the access through
the operator
\begin{verbatim}
 m(row,col) = value;
\end{verbatim}
may be mandatory.
In principle, if a new element is inserted into a matrix a new memory
cell has to be allocated for this element, and other elements may be 
moved.
Memory allocation is quite time consuming, and to reduce the overhead,
{\tt GSparseMatrix} can be configured to allocate memory in bunches.
By default, each time more matrix memory is needed, {\tt GSparseMatrix}
allocates 512 cells at once (or 6144 Bytes since each element requires 
a {\tt double} and a {\tt int} storage location).
If this amount of memory is not adequat one may change this value by
using
\begin{verbatim}
 m.set_mem_block(size);
\end{verbatim}
where {\tt size} is the number of matrix elements that should be
allocated at once (corresponding to a total memory of 
$12 \times {\tt size}$ Bytes).

Alternatively, a matrix may be filled column-wise using the functions
\begin{verbatim}
 m.insert_col(vector,col);              // Insert a vector in column
 m.add_col(vector,col);                 // Add content of a vector to column
\end{verbatim}
While {\tt insert\_col} sets the values of column {\tt col} (deleting 
thus any previously existing entries), {\tt add\_col} adds the content 
of {\tt vector} to all elements of column {\tt col}.
Using these functions is considerably more rapid than filling individual 
values.

Still, if the matrix is big (i.e. severeal thousands of rows and 
columns), filling individual columns may still be slow.
To speed-up dynamical matrix filling, an internal fill-stack has been 
implemented in {\tt GSparseMatrix}.
Instead of inserting values column-by-column, the columns are stored 
in a stack and filled into the matrix once the stack is full.
This reduces the number of dynamic memory allocations to let the 
matrix grow as it is built.
By default, the internal stack is disabled.
The stack can be enabled and used as follows:
\begin{verbatim}
 m.stack_init(size, entries);           // Initialise stack
 ...
 m.add_col(vector,col);                 // Add columns
 ...
 m.stack_destroy();                     // Flush and destory stack
\end{verbatim}
The method {\tt stack\_init} initialises a stack with a number of 
{\tt size} elements and a maximum of {\tt entries} columns.
The larger the values {\tt size} and {\tt entries} are chosen, the
more efficient the stack works.
The total amount of memory of the stack can be estimated as
$12 \times {\tt size} + 8 \times {\tt entries}$ Bytes.
If a rough estimate of the total number of non-zero elements is
available it is recommended to set {\tt size} to this value.
As a rule of thumb, {\tt size} should be at least of the dimension of 
either the number of rows or the number of columns of the matrix 
(take the maximum of both).
{\tt entries} is best set to the number of columns of the matrix.
If memory limits are an issue smaller values may be set, but if the
values are too small, the speed increase may become negligible (or 
stack-filling may even become slower than normal filling).

Stack-filling only works with the method {\tt add\_col}.
Note also that filling sub-sequently the same column leads to stack 
flushing.
In the code
\begin{verbatim}
 for (int col = 0; col < 100; ++col) {
   column      = 0.0;                   // Reset column
   column(col) = col;                   // Set column
   m.add_col(column,col);               // Add column
 }   
\end{verbatim}
stack flushing occurs in each loop, and consequently, the 
stack-filling approach will be not very efficient (it 
would probably be even slover than normal filling).
If successive operations are to be performed on columns, 
it is better to perform them before adding.
The code
\begin{verbatim}
 column = 0.0;                          // Reset column
 for (int col = 0; col < 100; ++col)
   column(col) = col;                   // Set column
 m.add_col(column,col);                 // Add column
\end{verbatim}
would be far more efficient.

A avoidable overhead occurs for the case that the column to be added 
is sparse.
The vector may contain many zeros, and {\tt GSparseMatrix} has to 
filter them out.
If the sparsity of the column is known, this overhead can be avoided 
by directly passing a compressed array to {\tt add\_col}:
\begin{verbatim}
 int     number = 5;                    // 5 elements in array
 double* values = new double[number];   // Allocate values
 int*    rows   = new int[number];      // Allocate row index
 ...
 m.stack_init(size, entries);           // Initialise stack
 ...
 for (int i = 0; i < number; ++i) {     // Initialise array
   values[i] = ...                      // ... set values
   rows[i]   = ...                      // ... set row indices
 }
 ...
 m.add_col(values,rows,number,col);     // Add array
 ...
 m.stack_destroy();                     // Flush and destory stack
 ...
 delete [] values;                      // Free array
 delete [] rows;
\end{verbatim}

The method {\tt add\_col} calls the method {\tt stack\_push\_column}
for stack filling.
{\tt add\_col} is more general than {\tt stack\_push\_column} in that 
it decides which of stack- or direct filling is more adequate.
In particular, {\tt stack\_push\_column} may refuse pushing a column 
onto the stack if there is not enough space.
In that case, {\tt stack\_push\_column} returns a non-zero value that 
corresponds to the number of non-zero elements in the vector that 
should be added.
However, it is recommended to not use {\tt stack\_push\_column} and 
call instead {\tt add\_col}.

The method {\tt stack\_destroy} is used to flush and destroy the
stack. 
After this call the stack memory is liberated.
If the stack should be flushed without destroying it, the method
{\tt stack\_flush} may be used:
\begin{verbatim}
 m.stack_init(size, entries);           // Initialise stack
 ...
 m.add_col(vector,col);                 // Add columns
 ...
 m.stack_flush();                       // Simply flush stack
\end{verbatim}
Once flushed, the stack can be filled anew.

Note that stack flushing is not automatic!
This means, if one trys to use a matrix for calculs without flushing, 
the calculs may be wrong.
{\bf If a stack is used for filling, always flush the stack before using 
the matrix.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code reference
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Code reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GApplication}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEbounds}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEnergy}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEvent} \small[abstract]}
{\tt GEvent} implements the abstract interface for a gamma-ray event.
It handles both event atoms (\ref{GEventAtom}) and event bins (\ref{GEventBin}).
\begin{verbatim}
  /* Constructors */
  GEvent(void);
  GEvent(const GEvent& event);

  /* Operators */
  GEvent& operator= (const GEvent& event);

  /* Methods */
  void            clear(void);         // Clear event
  GEvent*         clone(void) const;   // Clone event
  double          size(void) const;    // Returns size of event bin
  const GInstDir& dir(void) const;     // Returns event's instrument direction
  const GEnergy&  energy(void) const;  // Returns event energy
  const GTime&    time(void) const;    // Returns event time
  double          counts(void) const;  // Returns number of counts in event
  double          error(void) const;   // Returns uncertainty in number of counts in event
  bool            isatom(void) const;  // Event is an atom
  bool            isbin(void) const;   // Event is a bin
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEventAtom} \small[abstract]}
\label{GEventAtom}
{\tt GEventAtom} derives from {GEvent} and implements the abstract interface for an event
atom. 
Each atom is characterised by an instrument direction, an energy and an event arrival time. 
\begin{verbatim}
  /* Constructors */
  GEventAtom(void);
  GEventAtom(const GEventAtom& atom);

  /* Operators */
  GEventAtom& operator= (const GEventAtom& atom);

  /* Methods */
  void            clear(void);         // Clear event
  GEventAtom*     clone(void) const;   // Clone event
  double          size(void) const;    // Returns 1.0
  const GInstDir& dir(void) const;     // Returns event's instrument direction
  const GEnergy&  energy(void) const;  // Returns event energy
  const GTime&    time(void) const;    // Returns event time
  double          counts(void) const;  // Returns 1.0
  double          error(void) const;   // Returns 0.0
  bool            isatom(void) const;  // Returns true
  bool            isbin(void) const;   // Returns false
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEventBin} \small[abstract]}
\label{GEventBin}
{\tt GEventBin} derives from {GEvent} and implements the abstract interface for an event
bin.
Each bin is characterised by a mean instrument direction, a mean energy and a
mean event arrival time.
The size of the event bin is the solid angle subtended by the event bin times the energy 
width times the time interval that is covered.
Multiplication of the event occurence probability with the bin size provides the expected
number of counts in a bin.
\begin{verbatim}
  /* Constructors */
  GEventBin(void);
  GEventBin(const GEventBin& bin);

  /* Operators */
  GEventBin& operator= (const GEventBin& bin);

  /* Methods */
  void            clear(void);         // Clear event bin
  GEventBin*      clone(void) const;   // Clone event bin
  double          size(void) const;    // Returns size of event bin
  const GInstDir& dir(void) const;     // Returns bin's mean instrument direction
  const GEnergy&  energy(void) const;  // Returns mean bin energy
  const GTime&    time(void) const;    // Returns mean bin time
  double          counts(void) const;  // Returns number of events in bin
  double          error(void) const;   // Returns uncertainty in number of events in bin
  bool            isatom(void) const;  // Returns false
  bool            isbin(void) const;   // Returns true
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEvents} \small[abstract]}
Events are collected in the abstract container class {\tt GEvents}.
This class handles both event lists (\ref{GEventList}) and event cubes (\ref{GEventCube}).
\begin{verbatim}
  /* Constructors */
  GEvents(void);
  GEvents(const GEvents& events);

  /* Operators */
  GEvents& operator= (const GEvents& events);

  /* Methods */
  void     clear(void);                       // Clear events
  GEvents* clone(void) const;                 // Clone events
  int      size(void) const;                  // Returns number of atoms or bins
  void     load(const std::string& filename); // Load events from file
  GEvent*  pointer(int index);                // Returns pointer on atom or bin
  int      number(void) const;                // Returns number of events
  bool     islist(void) const;                // Object is event list
  bool     iscube(void) const;                // Object is event cube
  iterator begin(void);                       // Returns iterator on first atom or bin
  iterator end(void);                         // Returns iterator on last atom or bin
\end{verbatim}
{\tt GEvents} implements an event iterator as a nested class 
{\tt GEvents::iterator} with the following definition:
\begin{verbatim}
  /* Constructor */
  iterator(void);
  iterator(GEvents *events);

  /* Operators */
  iterator& operator++(void);
  iterator  operator++(int junk);
  bool      operator==(const iterator& it) const;
  bool      operator!=(const iterator& it) const;
  GEvent&   operator*(void);
  GEvent*   operator->(void);
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEventList} \small[abstract]}
\label{GEventList}
{\tt GEventList} is an abstract container class for event atoms.
\begin{verbatim}
  /* Constructors */
  GEventList(void);
  GEventList(const GEventList& list);

  /* Operators */
  GEventList& operator= (const GEventList& list);
  
  /* Methods */
  void        clear(void);                       // Clear event list
  GEventList* clone(void) const;                 // Clone event list
  int         size(void) const;                  // Returns number of events in list
  void        load(const std::string& filename); // Load list from file
  GEventAtom* pointer(int index);                // Returns pointer on event atom
  int         number(void) const;                // Returns number of events in list
  bool        islist(void) const;                // Returns true
  bool        iscube(void) const;                // Returns false
  
  /* Friends */
  std::ostream& operator<< (std::ostream& os, const GEventList& list);
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GEventCube} \small[abstract]}
\label{GEventCube}
{\tt GEventCube} is an abstract container class for event bins.
\begin{verbatim}
  /* Constructors */
  GEventCube(void);
  GEventCube(const GEventCube& cube);

  /* Operators */
  GEventCube& operator= (const GEventCube& cube);
  
  /* Methods */
  void        clear(void);                       // Clear event cube
  GEventCube* clone(void) const;                 // Clone event cube
  int         size(void) const;                  // Returns number of bins in cube
  void        load(const std::string& filename); // Load cube from file
  GEventBin*  pointer(int index);                // Returns pointer on bin
  int         number(void) const;                // Returns number of events in cube
  int         dim(void) const;                   // Returns dimension of cube
  int         naxis(int axis) const;             // Returns dimension of cube axis
  bool        islist(void) const;                // Returns false
  bool        iscube(void) const;                // Returns true
  
  /* Friends */
  std::ostream& operator<< (std::ostream& os, const GEventCube& cube);
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GFits}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GGti}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GInstDir}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GIntegral}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GIntegrand}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GLog}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GMatrix}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModel}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModel(void);                                            // Creates empty model
GModel(const GModel& model);                             // Creates copy of model
GModel(const GModelSpatial& spatial,                     // Creates model from spatial and
       const GModelSpectral& spectral);                  //   spectral components
GModel(const GXmlElement& spatial,                       // Creates model from spatial and
       const GXmlElement& spectral);                     //   spectral XML elements

/* Operators */
GModelPar&       operator() (int index);                 // Returns reference to parameter
const GModelPar& operator() (int index) const;           // Returns reference to parameter
GModel&          operator= (const GModel& model);        // Assign model

/* Methods */
void            clear(void);                             // Clear model
GModel*         clone(void) const;                       // Clone model
int             size(void) const;                        // Returns number of parameters
std::string     name(void) const;                        // Returns model name
void            name(const std::string& name);           // Set model name
GModelSpatial*  spatial(void) const;                     // Returns spatial component
GModelSpectral* spectral(void) const;                    // Returns spectral component
GModelTemporal* temporal(void) const;                    // Returns temporal component
double          value(const GSkyDir& srcDir,             // Returns model value
                      const GEnergy& srcEng,
                      const GTime& srcTime); 
GVector         gradients(const GSkyDir& srcDir,         // Returns model gradient
                          const GEnergy& srcEng,
                          const GTime& srcTime); 
double          eval(const GEvent& event,                // Evaluates model for an event
                     const GObservation& obs);
double          eval_gradients(const GEvent& event,      // Evaluates model and gradients
                               const GObservation& obs); //   for an event
bool            isvalid(const std::string& name) const;  // Model applies to instrument?
std::string     print(void) const;                       // Print model
\end{verbatim}

\paragraph{Description:}
The {\tt GModel} class implements the factorized source model
\begin{equation}
S(\vec{p}, E, t) = M(\vec{p}) \times P(E) \times V(t)
\end{equation}
where
\begin{itemize}
\item[] $M(\vec{p})$ is a map of the intensity distribution (in units of sr$^{-1}$),
\item[] $P(E)$ is the source spectrum (in units of photons cm$^{-2}$ s$^{-1}$ MeV$^{-1}$), and
\item[] $V(t)$ is a source modulation function (unitless),
\item[] $\vec{p}$ is the true photon arrival direction,
\item[] $E$ is the true photon energy, and
\item[] $t$ is the true photon arrival time.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelPar}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelPar(void);                                          // Creates empty parameter
GModelPar(const GModelPar& par);                          // Creates copy of parameter

/* Operators */
GModelPar& operator= (const GModelPar& par);              // Assign parameter

/* Methods */
std::string name(void) const;                             // Returns name
std::string unit(void) const;                             // Returns unit
double      real_value(void) const;                       // Returns true value
double      real_error(void) const;                       // Returns true error
double      real_gradient(void) const;                    // Returns true gradient
double      real_min(void) const;                         // Returns true minimum
double      real_max(void) const;                         // Returns true maximum
double      value(void) const;                            // Returns value
double      error(void) const;                            // Returns error
double      gradient(void) const;                         // Returns gradient
double      min(void) const;                              // Returns minimum
double      max(void) const;                              // Returns maximum
double      scale(void) const;                            // Returns scale factor
bool        isfree(void) const;                           // Signals that parameter is free
bool        hasmin(void) const;                           // Signals that parameter has minimum
bool        hasmax(void) const;                           // Signals that parameter has maximum
void        name(const std::string& name);                // Set name
void        unit(const std::string& unit);                // Set unit
void        value(const double& value);                   // Set value
void        error(const double& error);                   // Set error
void        gradient(const double& gradient);             // Set gradient
void        min(const double& min);                       // Set minimum
void        max(const double& max);                       // Set maximum
void        scale(const double& scale);                   // Set scale factor
void        range(const double& min, const double& max);  // Set minimum and maximum
void        remove_min(void);                             // Remove minimum
void        remove_max(void);                             // Remove maximum
void        remove_range(void);                           // Remove minimum and maximum
void        free(void);                                   // Set parameter free
void        fix(void);                                    // Fix parameter
void        read(const GXmlElement& xml);                 // Read parameter from XML element
void        write(GXmlElement& xml) const;                // Write parameter into XML element
std::string print(void) const;                            // Print parameter
\end{verbatim}

\paragraph{Description:}
This class implements a model parameter.
The true parameter value is given by
\begin{equation}
{\tt true} = {\tt scale} \times {\tt value}
\end{equation}
and is accessed through the {\tt real\_} methods.
The optimizer will only affect the {\tt value} part of the parameter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModels}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModels(void);                                       // Creates empty model container
GModels(const GModels& models);                      // Creates copy of container
GModels(const std::string& filename);                // Creates container from XML file

/* Operators */
GModel&       operator() (int index);                // Returns reference to model
const GModel& operator() (int index) const;          // Returns reference to model
GModels&      operator= (const GModels& models);     // Assign model container

/* Methods */
void        clear(void);                             // Clear models
GModels*    clone(void) const;                       // Clone models
int         size(void) const;                        // Returns number of models in container
void        append(const GModel& model);             // Append model to container
void        load(const std::string& filename);       // Load models from XML file
void        save(const std::string& filename) const; // Save models into XML file
void        read(const GXml& xml);                   // Read models from XML document
void        write(GXml& xml) const;                  // Write models into XML document
int         npars(void) const;                       // Returns total number of parameters
int         nfree(void) const;                       // Returns total number of free parameters
GModelPar*  par(int index) const;                    // Returns pointer to model parameter
double      value(const GSkyDir& srcDir,             // Returns model value
                  const GEnergy& srcEng,
                  const GTime& srcTime);
double      eval(const GEvent& event,                // Evaluates models for an event
                 const GObservation& obs);
double      eval_gradients(const GEvent& event,      // Evaluates models and parameter
                           const GObservation& obs); //   gradients for an event
std::string print(void) const;                       // Print model
\end{verbatim}

\paragraph{Description:}
Container class for {\tt GModel} source models.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelSpatial} \small[abstract]}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelSpatial(void);                                      // Creates empty component
GModelSpatial(const GModelSpatial& model);                // Creates copy of component

/* Operators */
GModelPar&       operator() (int index);                  // Access model parameter
const GModelPar& operator() (int index) const;            // Access model parameter
GModelSpatial&   operator= (const GModelSpatial& model);  // Assign component

/* Methods */
void           clear(void);                               // Clear component
GModelSpatial* clone(void) const;                         // Clone component
int            size(void) const;                          // Returns number of model parameters
std::string    type(void) const;                          // Returns type of component
double         eval(const GSkyDir& srcDir);               // Evaluate component
double         eval_gradients(const GSkyDir& srcDir);     // Evaluate component and gradients
void           read(const GXmlElement& xml);              // Read component from XML element
void           write(GXmlElement& xml) const;             // Write component into XML element
bool           isptsource(void) const;                    // Signals if component is point source
std::string    print(void) const;                         // Print component
\end{verbatim}

\paragraph{Description:}
Implements the spatial component $M(\vec{p})$ of the factorized source model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelSpatialPtsrc}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelSpatialPtsrc(void);                             // Creates empty point source
GModelSpatialPtsrc(const GSkyDir& dir);               // Creates point source from sky direction
GModelSpatialPtsrc(const GXmlElement& xml);           // Creates point source from XML element
GModelSpatialPtsrc(const GModelSpatialPtsrc& model);  // Creates copy of point source

/* Operators */
GModelPar&          operator() (int index);                      // Access model parameter
const GModelPar&    operator() (int index) const;                // Access model parameter
GModelSpatialPtsrc& operator= (const GModelSpatialPtsrc& model); // Assign point source

/* Methods */
void                clear(void);                            // Clear point source
GModelSpatialPtsrc* clone(void) const;                      // Clone point source
int                 size(void) const;                       // Returns 2
std::string         type(void) const;                       // Returns "PointSource"
double              eval(const GSkyDir& srcDir);            // Evaluate point source
double              eval_gradients(const GSkyDir& srcDir);  // Evaluate point source and gradients
void                read(const GXmlElement& xml);           // Read point source from XML element
void                write(GXmlElement& xml) const;          // Write point source into XML element
bool                isptsource(void) const;                 // Returns true
double              ra(void) const;                         // Returns Right Ascension (deg)
double              dec(void) const;                        // Returns Declination (deg)
GSkyDir             dir(void) const;                        // Returns position of point source
void                dir(const GSkyDir& dir);                // Set position of point source
std::string         print(void) const;                      // Print component
\end{verbatim}

\paragraph{Description:}
Implements a point source model with parameters Right Ascension and Declination.

The {\tt eval} method returns 1 if the specified position coincides with the position
of the point source, 0 otherwise (coincidence is defined as the angular distance between
the specified and the point source position being inferior to 0.1 arcseconds).

The {\tt eval\_gradients} method sets both parameter gradients to 0.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelSpectral} \small[abstract]}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelSpectral(void);                                      // Creates empty component
GModelSpectral(const GModelSpectral& model);               // Creates copy of component

/* Operators */
GModelPar&       operator() (int index);                   // Access model parameter
const GModelPar& operator() (int index) const;             // Access model parameter
GModelSpectral&  operator= (const GModelSpectral& model);  // Assign component

/* Methods */
void            clear(void);                               // Clear component
GModelSpectral* clone(void) const;                         // Clone component
int             size(void) const;                          // Returns number of model parameters
std::string     type(void) const;                          // Returns type of component
double          eval(const GSkyDir& srcDir);               // Evaluate component
double          eval_gradients(const GSkyDir& srcDir);     // Evaluate component and gradients
void            read(const GXmlElement& xml);              // Read component from XML element
void            write(GXmlElement& xml) const;             // Write component into XML element
std::string     print(void) const;                         // Print component
\end{verbatim}

\paragraph{Description:}
Implements the spectra component $P(E)$ of the factorized source model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelSpectralPlaw}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelSpectralPlaw(void);                             // Creates empty power law
GModelSpectralPlaw(const double& norm,);              // Creates power law from
                   const double& index);              //   normalization and index
GModelSpectralPlaw(const GXmlElement& xml);           // Creates power law from XML element
GModelSpectralPlaw(const GModelSpectralPlaw& model);  // Creates copy of power law

/* Operators */
GModelPar&          operator() (int index);                      // Access model parameter
const GModelPar&    operator() (int index) const;                // Access model parameter
GModelSpectralPlaw& operator= (const GModelSpectralPlaw& model); // Assign power law

/* Methods */
void                clear(void);                            // Clear power law
GModelSpectralPlaw* clone(void) const;                      // Clone power law
int                 size(void) const;                       // Returns 3
std::string         type(void) const;                       // Returns "PowerLaw"
double              eval(const GEnergy& srcEng);            // Evaluate power law
double              eval_gradients(const GEnergy& srcEng);  // Evaluate power law and gradients
void                read(const GXmlElement& xml);           // Read power law from XML element
void                write(GXmlElement& xml) const;          // Write power law into XML element
void                autoscale(void);                        // Automatically scale normalization
double              norm(void) const;                       // Returns normalization
double              index(void) const;                      // Returns index
double              pivot(void) const;                      // Returns pivot energy (MeV)
std::string         print(void) const;                      // Print power law
\end{verbatim}

\paragraph{Description:}
Implements power law spectral model
\begin{equation}
I(E) = {\tt norm} \, (E/{\tt pivot})^{{\tt index}}
\end{equation}
where
${\tt norm}=n_s n_v$ is the normalization or prefactor (units ph/cm$^2$/s/MeV),
${\tt index}=i_s i_v$ is the spectral index, and
${\tt pivot}=p_s p_v$ is the pivot energy (units MeV).
Note that each parameter is factorised into a scaling factor (indexed by $s$) and a 
parameter value (indexed by $v$).
This function is evaluated using the {\tt eval} method.

The {\tt eval\_gradients} methods computes in addition the partial derivatives of 
the parameter values:
\begin{eqnarray}
dI/dn_v &= & n_s (E/{\tt pivot})^{{\tt index}} \\
dI/di_v & = & {\tt norm} (E/{\tt pivot})^{{\tt index}} i_s \ln(E/{\tt pivot}) \\
dI/dp_v & = & {\tt norm} (E/{\tt pivot})^{{\tt index}} (-{\tt index}) / p_v
\end{eqnarray}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelSpectralExpPlaw}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelSpectralExpPlaw(void);                               // Creates empty cutoff power law
GModelSpectralExpPlaw(const double& norm,);                // Creates cutoff power law from
                      const double& index,                 //   normalization, index and
                      const double& ecut);                 //   exponential cutoff energy
GModelSpectralExpPlaw(const GXmlElement& xml);             // Creates cutoff PL from XML element
GModelSpectralExpPlaw(const GModelSpectralExpPlaw& model); // Creates copy of cutoff power law

/* Operators */
GModelPar&             operator() (int index);                         // Access model parameter
const GModelPar&       operator() (int index) const;                   // Access model parameter
GModelSpectralExpPlaw& operator= (const GModelSpectralExpPlaw& model); // Assign cutoff power law

/* Methods */
void                   clear(void);                            // Clear cutoff power law
GModelSpectralExpPlaw* clone(void) const;                      // Clone cutoff power law
int                    size(void) const;                       // Returns 4
std::string            type(void) const;                       // Returns "ExpCutoff"
double                 eval(const GEnergy& srcEng);            // Evaluate cutoff power law
double                 eval_gradients(const GEnergy& srcEng);  // Evaluate cutoff PL and gradients
void                   read(const GXmlElement& xml);           // Read cutoff PL from XML element
void                   write(GXmlElement& xml) const;          // Write cutoff PL into XML element
void                   autoscale(void);                        // Automatically scale normalization
double                 norm(void) const;                       // Returns normalization
double                 index(void) const;                      // Returns index
double                 ecut(void) const;                       // Returns cutoff energy (MeV)
double                 pivot(void) const;                      // Returns pivot energy (MeV)
std::string            print(void) const;                      // Print cutoff power law
\end{verbatim}

\paragraph{Description:}
Implements power law spectral model
\begin{equation}
I(E) = {\tt norm} \, (E/{\tt pivot})^{{\tt index}} \exp(-E/{\tt ecut})
\end{equation}
where
${\tt norm}=n_s n_v$ is the normalization or prefactor (units ph/cm$^2$/s/MeV),
${\tt index}=i_s i_v$ is the spectral index,
${\tt ecut}=c_s c_v$ is the cutoff energy (units MeV), and
${\tt pivot}=p_s p_v$ is the pivot energy (units MeV).
Note that each parameter is factorised into a scaling factor (indexed by $s$) and a 
parameter value (indexed by $v$).
This function is evaluated using the {\tt eval} method.

The {\tt eval\_gradients} methods computes in addition the partial derivatives of 
the parameter values:
\begin{eqnarray}
dI/dn_v &= & n_s (E/{\tt pivot})^{{\tt index}}  \exp(-E/{\tt ecut}) \\
dI/di_v & = & {\tt norm} (E/{\tt pivot})^{{\tt index}}  \exp(-E/{\tt ecut}) i_s \ln(E/{\tt pivot}) \\
dI/dc_v & = & {\tt norm} (E/{\tt pivot})^{{\tt index}} \exp(-E/{\tt ecut}) (E/{\tt ecut}^2) c_s \\
dI/dp_v & = & {\tt norm} (E/{\tt pivot})^{{\tt index}}  \exp(-E/{\tt ecut}) (-{\tt index}) / p_v
\end{eqnarray}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelTemporal} \small[abstract]}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelTemporal(void);                                      // Creates empty component
GModelTemporal(const GModelTemporal& model);               // Creates copy of component

/* Operators */
GModelPar&       operator() (int index);                   // Access model parameter
const GModelPar& operator() (int index) const;             // Access model parameter
GModelTemporal&  operator= (const GModelTemporal& model);  // Assign component

/* Methods */
void            clear(void);                               // Clear component
GModelTemporal* clone(void) const;                         // Clone component
int             size(void) const;                          // Returns number of model parameters
std::string     type(void) const;                          // Returns type of component
double          eval(const GTime& srcTime);                // Evaluate component
double          eval_gradients(const GTime& srcTime);      // Evaluate component and gradients
void            read(const GXmlElement& xml);              // Read component from XML element
void            write(GXmlElement& xml) const;             // Write component into XML element
std::string     print(void) const;                         // Print component
\end{verbatim}

\paragraph{Description:}
Implements the temporal component $V(t)$ of the factorized source model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{{\tt GModelTemporalConst}}

\paragraph{Class definition:}
\begin{verbatim}
/* Constructors */
GModelTemporalConst(void);                                         // Creates empty component
GModelTemporalConst(const GModelTemporalConst& model);             // Creates copy of component

/* Operators */
GModelPar&           operator() (int index);                       // Access model parameter
const GModelPar&     operator() (int index) const;                 // Access model parameter
GModelTemporalConst& operator= (const GModelTemporalConst& model); // Assign component

/* Methods */
void                 clear(void);                           // Clear component
GModelTemporalConst* clone(void) const;                     // Clone component
int                  size(void) const;                      // Returns 1
std::string          type(void) const;                      // Returns "Constant"
double               eval(const GTime& srcTime);            // Evaluate component
double               eval_gradients(const GTime& srcTime);  // Evaluate component and gradients
void                 read(const GXmlElement& xml);          // Read component from XML element
void                 write(GXmlElement& xml) const;         // Write component into XML element
std::string          print(void) const;                     // Print component
\end{verbatim}

\paragraph{Description:}
Implements a non-variable (constant) source.

The {\tt eval} method returns 1, the {\tt eval\_gradients} methods sets the gradient to 0.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GNodeArray}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GObservation}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GObservations}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GOptimizer}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GOptimizerFunction}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GOptimizerLM}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GOptimizerPars}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GPar}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GPars}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GPointing}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GResponse}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GRoi}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GSkyDir}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GSkymap}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GSkyPixel}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GSparseMatrix}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GSymMatrix}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GTime}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GTools}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GVector}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GWcs}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GWcsCAR}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GWcsHPX}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXml}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlAttribute}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlComment}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlDocument}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlElement}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlNode}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlPI}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{{\tt GXmlText}}


\end{document} 
