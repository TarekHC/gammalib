%---------------------------------------------------------------------------- %                             GammaLib User Manual%% Version .........: 0.0.0% Last modification: 26 October 2006%----------------------------------------------------------------------------%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definitions for manual package%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\newcommand{\task}{\mbox{GammaLib}}\newcommand{\this}{\mbox{\tt \task}}\newcommand{\version}{\mbox{0.0.0}}\newcommand{\calendar}{\mbox{26 October 2006}}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Document definition%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\documentclass{article}[12pt,a4]\usepackage{epsfig}\usepackage{manual}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin of document body%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{document}\frontpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Introduction%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{Introduction}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{Motivation}Again another library?Indeed, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{Philisophy}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{Implementation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GammaLib objects%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{\this\ objects}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{Vectors and matrices}%----------------------------------------------------------------------------\subsubsection{General}Most of the calculations that are needed in data analysis can be expressed as vector and matrix operations.For this reason, \this\ provides a vector and matrix package that is implemeted as the {\tt GVector} and the {\tt GMatrix} classes.%----------------------------------------------------------------------------\subsubsection{Matrix storage classes}The matrix base class is {\tt GMatrix} which stores all elements of the matrix (including zeros) in a full array.The full array has the dimensions {\tt rows} $\times$ {\tt cols}, matrix elements are stored in column major format.Derived matrix classes exist for more compact storage modes, reducing the memory requirements for handling and storing the information.{\tt GSymMatrix} symmetric matrix.{\tt GSparseMatrix} sparse matrix.The following description of the matrix class properties apply to all matrix storage classes, if not stated otherwise. %----------------------------------------------------------------------------\subsubsection{Matrix arithmetics}{\tt GMatrix} and its derived objects can be added, subtracted, scaled and negated, very much as other data types.The following code fragment illustrates the usage:\begin{verbatim} // Matrix allocation GMatrix A(2,3); GMatrix B(3,2); GMatrix C(2,2); GMatrix D(2,2);  // Element assignment A(0,0) = A(1,1) = A(1,2) = 1.0; B(0,0) = B(1,1) = B(2,1) = 1.0; D(0,0) = D(1,1) = 1.0;  // Arithmetics C = A * B;                 // Matrix multiplication D = C;                     // Assignment C = C * 2.0;               // Multiplication of all matrix elements by 2.0 D = D + D - C;             // Matrix addition and subtraction C = -D;                    // Negation of all matrix elements A *= 5.0;                  // Multiplication of all matrix elements by 5.0\end{verbatim}Matrix allocation requires {\bf always} the specification of the number of rows and columns of the matrix.This means that there is no such thing as a matrix object with zero rows or columns.All matrix elements are initialised to 0.0 by the matrix allocation.Matrix elements are accessed by the {\tt matrix(row,col)} function,where {\tt row} and {\tt col} start from 0 for the first row or column and run up to the number of rows or columns minus 1.Matrix arithmetics comprise binary operators {\tt C = A operator B} andunary operators {\tt C operator A}. {\tt A} and {\tt B} may be either{\tt GMatrix} (or derived) objects or {\tt double} values. The following fundamental operations exist for all matrices:\begin{verbatim} C = A + B;                 // Matrix addition C = A - B;                 // Matrix subtraction C = A * B;                 // Matrix multiplication C = A * v;                 // Matrix vector multiplication C = A * s;                 // Matrix scalar multiplication C = s * A;                 // Matrix scalar multiplication (left sided) C = A * s;                 // Matrix scalar multiplication (right sided) C = A / s;                 // Matrix scalar division C = -A;                    // Negation A += B;                    // Matrix inplace addition A -= B;                    // Matrix inplace subtraction A *= B;                    // Matrix inplace multiplications A *= s;                    // Matrix inplace scalar multiplication A /= s;                    // Matrix inplace scalar division\end{verbatim}Note that all {\bf inplace operations}, such as the {\tt +=},{\tt -=},{\tt *=}, and{\tt /=} operators do not require the allocation of additionalmemory to hold the matrix result elements, hence inplace operationsmay be preferable if memory requirements are an issue.Matrices may be compared to each other using\begin{verbatim} int identical = (A == B);  // True if all matrix elements are identical                            // and if the matrices have identical dimensions int different = (A != B);  // True if at least one matrix element differs                            // or if the matrices have different dimensions\end{verbatim}%----------------------------------------------------------------------------\subsubsection{Matrix functions}Matrix attributes:\begin{verbatim} unsigned rows = M.rows();   // Returns number of rows in matrix unsigned cols = M.cols();   // Returns number of columns in matrix\end{verbatim}Matrix information:\begin{verbatim} double sum = M.sum();       // Sum of all elements in matrix double min = M.min();       // Returns minimum element of matrix double max = M.max();       // Returns maximum element of matrix\end{verbatim}%----------------------------------------------------------------------------\subsubsection{Matrix factorisations}A general tool of numeric matrix calculs is factorisation.Solve linear equation {\tt Ax = b}.Inverse a matrix (by solving successively {\tt Ax = e}, where {\tt e} are the unit vectors for all dimensions).%\paragraph{Matrix factorisations}For symmetric and positive definite matrices the most efficient factorisation is the Cholesky decomposition.The following code fragment illustrates the usage:\begin{verbatim} GMatrix A(n_rows, n_cols}; GVector x(n_rows}; GVector b(n_rows}; ... A.cholesky_decompose();     // Perform Cholesky factorisation x = A.cholesky_solver(b);   // Solve Ax=b for x\end{verbatim}Note that once the function {\tt A.cholesky\_decompose()} has been applied, the original matrix content has been replaced by its Cholesky decomposition.Since the Cholesky decomposition can be performed inplace (i.e. without the allocation of additional memory to hold the result), the matrix replacement is most memory economic.In case that the original matrix should be kept, one may either copy it before into another {\tt GMatrix} object or use the function\begin{verbatim} GMatrix L = cholesky_decompose(A); x = L.cholesky_solver(b);\end{verbatim}A symmetric and positif definite matrix can be inverted using the Cholesky decomposition using\begin{verbatim} A.cholesky_invert();        // Inverse matrix using Cholesky factorisation\end{verbatim}Alternatively, the function \begin{verbatim} GMatrix A_inv = cholesky_invert(A);\end{verbatim}may be used.The Cholesky decomposition, solver and inversionroutines may also be applied to matrices that contain rows orcolumns that are filled by zeros.In this case the functions provide the option to (logically)compress the matrices by skipping the zero rows and columns duringthe calculation.For compressed matrix Cholesky factorisation, only the non-zero rows and columns have to be symmetric and positive definite.In particular, the full matrix may even be non-symmetric.%----------------------------------------------------------------------------\subsubsection{Sparse matrix}%%%%%\paragraph{General}\this\ provides a sparse matrix storage type that can save considerable amounts of memory for calculations.Assigment possible.The only exception that does not work is\begin{verbatim} GSparseMatrix A; A(0,0) = A(1,1) = A(2,2) = 1.0;\end{verbatim}In this case the value {\tt 1.0} is only assigned to the last element, i.e. {\tt A(2,2)}.Inverting a sparse matrix produces in general a full matrix, so the inversion function should be used with caution.Note that a full matrix that is stored in sparse format takes roughlytwice the memory than a normal {\tt GMatrix} object.If nevertheless the inverse of a sparse matrix should be examined, it is recommended to perform the analysis column-wise:\begin{verbatim} GSparseMatrix A(rows,cols);                // Allocate sparse matrix GVector       unit(rows);                  // Allocate vector ... A.cholesky_decompose();                    // Factorise matrix // Column-wise solving the matrix equation for (int col = 0; col < m_cols; ++col) {   unit(col) = 1.0;                         // Set unit vector   GVector x = cholesky_solver(unit);       // Get column x of inverse   ...   unit(col) = 0.0;                         // Clear unit vector for next round }\end{verbatim}%%%%%\paragraph{Filling of a sparse matrix}The filling of a sparse matrix is a tricky issue since the storageof the elements depends on their distribution in the matrix.If one would know beforehand this distribution, sparse matrix fillingwould be easy and fast.In general, however, the distribution is not known a priori, andmatrix filling may become a quite time consuming task.If a matrix has to be filled element by element, the access throughthe operator\begin{verbatim} m(row,col) = value;\end{verbatim}may be mandatory.In principle, if a new element is inserted into a matrix a new memorycell has to be allocated for this element, and other elements may be moved.Memory allocation is quite time consuming, and to reduce the overhead,{\tt GSparseMatrix} can be configured to allocate memory in bunches.By default, each time more matrix memory is needed, {\tt GSparseMatrix}allocates 512 cells at once (or 6144 Bytes since each element requires a {\tt double} and a {\tt int} storage location).If this amount of memory is not adequat one may change this value byusing\begin{verbatim} m.set_mem_block(size);\end{verbatim}where {\tt size} is the number of matrix elements that should beallocated at once (corresponding to a total memory of $12 \times {\tt size}$ Bytes).Alternatively, a matrix may be filled column-wise using the functions\begin{verbatim} m.insert_col(vector,col);                  // Insert a vector in column m.add_col(vector,col);                     // Add content of a vector to column\end{verbatim}While {\tt insert\_col} sets the values of column {\tt col} (deleting thus any previously existing entries), {\tt add\_col} adds the content of {\tt vector} to all elements of column {\tt col}.Using these functions is considerably more rapid than filling individual values.Still, if the matrix is big (i.e. severeal thousands of rows and columns), filling individual columns may still be slow.To speed-up dynamical matrix filling, an internal fill-stack has been implemented in {\tt GSparseMatrix}.Instead of inserting values column-by-column, the columns are stored in a stack and filled into the matrix once the stack is full.This reduces the number of dynamic memory allocations to let the matrix grow as it is built.By default, the internal stack is disabled.The stack can be enabled and used as follows:\begin{verbatim} m.stack_init(size, entries);               // Initialise stack ... m.add_col(vector,col);                     // Add columns ... m.stack_destroy();                         // Flush and destory stack\end{verbatim}The method {\tt stack\_init} initialises a stack with a number of {\tt size} elements and a maximum of {\tt entries} columns.The larger the values {\tt size} and {\tt entries} are chosen, themore efficient the stack works.The total amount of memory of the stack can be estimated as$12 \times {\tt size} + 8 \times {\tt entries}$ Bytes.If a rough estimate of the total number of non-zero elements isavailable it is recommended to set {\tt size} to this value.As a rule of thumb, {\tt size} should be at least of the dimension of either the number of rows or the number of columns of the matrix (take the maximum of both).{\tt entries} is best set to the number of columns of the matrix.If memory limits are an issue smaller values may be set, but if thevalues are too small, the speed increase may become negligible (or even, stack-filling may become slower than normal filling).Stack-filling only works with the method {\tt add\_col}.Note also that filling sub-sequently the same row leads to stack flushing, so if the same column is filled in a loop, i.e.\begin{verbatim} for (int col = 0; col < 100; ++col) {   column    = 0.0;                         // Reset column   column(i) = i;                           // Set column   m.add_col(column,col);                   // Add column }   \end{verbatim}it is better to fill the column before adding, i.e.\begin{verbatim} column    = 0.0;                           // Reset column for (int col = 0; col < 100; ++col)   column(i) = i;                           // Set column\end{verbatim}The method {\tt add\_col} calls the method {\tt stack\_push\_column}for stack filling.{\tt add\_col} is more general than {\tt stack\_push\_column} in that it decides which of stack- or direct filling is more adequate.In particular, {\tt stack\_push\_column} may refuse pushing a column onto the stack if there is not enough space.In that case, {\tt stack\_push\_column} returns a non-zero value that corresponds to the number of non-zero elements in the vector that should be added.However, it is recommended to not use {\tt stack\_push\_column} and call instead {\tt add\_col}.The method {\tt stack\_destroy} is used to flush and destroy thestack. After this call the stack memory is liberated.If the stack should be flushed without destroying it, the method{\tt stack\_flush} may be used:\begin{verbatim} m.stack_init(size, entries);               // Initialise stack ... m.add_col(vector,col);                     // Add columns ... m.stack_flush();                           // Simply flush stack\end{verbatim}Once flushed, the stack can be filled anew.Note that stack flushing is not automatic!This means, if one trys to use a matrix for calculs without flushing, the calculs may be work.{\bf If a stack is used for filling, always flush the stack before using the matrix.}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Code reference%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\clearpage\section{Code reference}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{{\tt GVector}}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{{\tt GMatrix}}\end{document} 